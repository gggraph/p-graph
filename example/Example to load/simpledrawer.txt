80
bang
9
# [bang] can trigger output on mouse down 
#        & has visual effect on receiving data
#                      |
#                    [bang]
#                      |
--decl
inp(1); outp(1)
--code
out0(0)
clock
12
# [clock] output its message after one second
#         
#                     *   
#                     |     
#                [ clock  ]
#                     |
--decl
inp(1)
outp(1)
--code
await wait(1000)
out0(0)
color
13
# [color] set color for [pix] [fill] 
#            and other graphics box
#
#                  *  r  g b
#                  |  |  |  |
#                [   color  ]
#                  |                  
--decl
inp(4)
outp(1)
--code
SetColor(mem(1),mem(2),mem(3))
out0(0)
fill
11
# [fill] clear display with current color 
#        
#                      |
#                    [fill]
#                      |                      
--decl
inp(1)
outp(1)
--code
ClearScreen()
out0(0)
inc
13
# [inc] increment its memory every time 
#        it is triggered
#                          set
#                      |  |
#                    [inc  ]
#                      |
--decl
inp(2)
outp(1)
memset(2)
--code
mem(1)+=1;
out0(1);
log
10
# [log] print its memory to browser
#         console
#
#                      |
#                    [log]
#                      
--decl
inp(1);outp(0);
--code
console.log(mem(0))
pix
11
# [pix] print a pixel on screen at position x and y
#       
#                *  x   y
#                |  |   |
#               [pix      ]
#                |
#
--decl
inp(3); outp(1)
--code
SetPixel(mem(1),mem(2))
pen
14
# [pen] set resolution of screen pixel 
#          printing command
#
#                  *  res 
#                  |   |   
#               [pen    ]
#                |
#
--decl
inp(2)
outp(1)
--code
SetPenWidth(mem(1))
out0(0)
pipe
13
# [pipe] output its message after a certain time
#         time set in input#2 is in ms
#                 *   time
#                 |     |
#                [ pipe  ]
#                 |
--decl
inp(2)
outp(1)
mem(1)=1000
--code
await wait(mem(1))
out0(0)
slider
6
# [slider] outputs integer with
#             special interaction
--decl
inp(1); outp(1);
--code
out0(0)
knob
7
# [knob] outputs integer with
#             special interaction
--decl
inp(1)
outp(1)
--code
out0(0)
number
7
# [number] outputs integer with
#             a special display
--decl
inp(1)
outp(1)
--code
out0(0)
floor
11
# [floor] round a value to its lowest 
#
#                      |
#                    [floor]
#                      |
--decl
inp(1)
outp(1)
--code
mem(0) = Math.floor(mem(0))
out0(0)
/
12
# [ / ] divide a number with
#       divider pass in second entry
#
#	          q   d
#                      |  |
#                    [ /   ]
#                      |
--decl
inp(2); outp(1);
--code
mem(0) /= mem(1)
out0(0)
switch
11
# [switch] pass or block routine
#              on click, user can set to 0 or I
#	          
#                      |   
#                    [switch]
#                      |
--decl
inp(2)
outp(1)
--code
if (mem(1)==0){out0(0);}
rand
18
# [rand]  out a random number 
#            range can be set by passing
#            minimum value at entry 1
#            maximum value at entry 2
#
#                  *  m   mx
#                  |   |   |
#                [rand     ]
#                  |
--decl
inp(3)
outp(1)
mem(1)=0
mem(2)=200
--code
mem(0) = Math.random() * (mem(2)-mem(1))+ mem(1)
mem(0) = Math.floor(mem(0))
out0(0)
metro
0
+
5
--decl
inp(2); outp(1);
--code
mem(0) += mem(1)
out0(0)
-
5
--decl
inp(2); outp(1);
--code
mem(0) -= mem(1)
out0(0)
<
4
--decl
inp(2); outp(2);
--code
if ( mem(0) < mem(1) ){ out0(0);} else{ out1(0)}
>
4
--decl
inp(2); outp(2);
--code
if ( mem(0) > mem(1) ){ out0(0);}else{ out1(0)}
*
5
--decl
inp(2); outp(1);
--code
mem(0) *= mem(1)
out0(0)
>=
4
--decl
inp(2); outp(2);
--code
if ( mem(0) >= mem(1) ){ out0(0);}else{ out1(0)}
<=
4
--decl
inp(2); outp(2);
--code
if ( mem(0) <= mem(1) ){ out0(0);}else{ out1(0)}
==
4
--decl
inp(2); outp(2);
--code
if ( mem(0) == mem(1) ){ out0(0);}else{ out1(0)}
zero
10
# [zero] output 0
#        
#                      |
#                    [zero]
#                      |
--decl
inp(1); outp(1)
--code
mem(0) =0
out0(0)
one
10
# [one] output 1
#        
#                      |
#                    [one]
#                      |
--decl
inp(1); outp(1)
--code
mem(0) =1
out0(0)
hashmux32
75
# [hashmux32] output 32 values between 0 and 255
#                     from a hash string
#
#             |
#         [hashmux32                               ]
#             ||||||||||||||||||||||||||||||||
--decl
inp(1)
outp(32)
memset(32)
--code
mem(0) = HashMux32(mem(0))
mem(1) = mem(0)[1]
mem(2) = mem(0)[2]
mem(3) = mem(0)[3]
mem(4) = mem(0)[4]
mem(5) = mem(0)[5]
mem(6) = mem(0)[6]
mem(7) = mem(0)[7]
mem(8) = mem(0)[8]
mem(9) = mem(0)[9]
mem(10) = mem(0)[10]
mem(11) = mem(0)[11]
mem(12) = mem(0)[12]
mem(13) = mem(0)[13]
mem(14) = mem(0)[14]
mem(15) = mem(0)[15]
mem(16) = mem(0)[16]
mem(17) = mem(0)[17]
mem(18) = mem(0)[18]
mem(19) = mem(0)[19]
mem(20) = mem(0)[20]
mem(21) = mem(0)[21]
mem(22) = mem(0)[22]
mem(23) = mem(0)[23]
mem(24) = mem(0)[25]
mem(26) = mem(0)[26]
mem(27) = mem(0)[27]
mem(28) = mem(0)[28]
mem(29) = mem(0)[29]
mem(30) = mem(0)[30]
mem(31) = mem(0)[31]
mem(0) = mem(0)[0]
out0(0)
out1(1)
out2(2)
out3(3)
out4(4)
out5(5)
out6(6)
out7(7)
out8(8)
out9(9)
out10(10)
out11(11)
out12(12)
out13(13)
out14(14)
out15(15)
out16(16)
out17(17)
out18(18)
out19(19)
out20(20)
out21(21)
out22(22)
out23(23)
out24(24)
out25(25)
out26(26)
out27(27)
out28(28)
out29(29)
out30(30)
out31(31)
int
0
str
0
loadblock
13
# [loadblock] load a block at index in its internal memory 
#             then outputs it
#
#               index
#            |    |
#         [loadblock] 
#              |
--decl
inp(2)
outp(1)
--code
mem(0) = await Network.LoadBlockAtIndex(mem(1))
out0(0)
chainheight
12
# [chainheight] outputs blockchain length when triggered
#               as number
#
#               |
#         [chainheight]
#               |
--decl
inp(1)
outp(1)
--code
mem(0) = await Network.GetBlockchainLength()
out0(0)
blockhash
13
# [blockhash] output hash of a block as a string
#
#            block 
#              |    
#         [blockhash] 
#              |
--decl
inp(1)
outp(1)
--code
if ( mem(0).hash != 'undefined'){Network.SetInternalBlock(mem(0));}
mem(0) = Network.GetBlockHash();
out0(0)
blocktime
14
# [blocktime] output timestamp of a block as UNIX 
#	      timestamp
#
#            block 
#              |    
#         [blocktime] 
#              |
--decl
inp(1)
outp(1)
--code
if ( mem(0).timestamp != 'undefined'){Network.SetInternalBlock(mem(0));}
mem(0) = Network.GetTimeStamp();
out0(0)
blockheight
14
# [blockheight] output height of a block
#	        
#
#            block 
#              |    
#         [blockheight] 
#              |
--decl
inp(1)
outp(1)
--code
if ( mem(0).timestamp != 'undefined'){Network.SetInternalBlock(mem(0));}
mem(0) = Network.GetBlockIndex();
out0(0)
hashlerp
12
# [hashlerp] lerp hash value between 0 and 1
#                
#
#               |
#         [hashlerp  ]
#               |
--decl
inp(1)
outp(1)
--code
mem(0) = LerpHash(mem(0))
out0(0)
sel
0
gate
11
# [gate]  pass or block routine 
#            if second input above 0
#	          
#                      |    |
#                    [gate ]
#                      |   
--decl
inp(2)
outp(1)
--code
if (mem(1)==0){out0(0);}
onload
8
# [onload] bang when project open
#                      
#                    [onload]
#                      |
--decl
inp(0); outp(1)
--code
out0(0)
dec
13
# [dec] decrement its memory every time 
#        it is triggered
#                          set
#                      |  |
#                    [dec  ]
#                      |
--decl
inp(2)
outp(1)
memset(2)
--code
mem(1)-=1;
out0(1);
sin~
14
# [sin~]  outputs a sine wave
#        
#                      *    freq  length
#                      |    |       |
#                    [sin~         ]
#                      |
--decl
inp(3)
outp(1)
mem(1)=800
mem(2)=0.1
--code
mem(0) = new Wave("sine",mem(1),mem(2))
out0(0)
sqr~
14
# [sqr~]  outputs a square wave
#        
#                      *    freq  length
#                      |    |       |
#                    [sqr~         ]
#                      |
--decl
inp(3)
outp(1)
mem(1)=800
mem(2)=0.1
--code
mem(0) = new Wave("square",mem(1),mem(2))
out0(0)
tri~
14
# [tri~]  outputs a triangle wave
#        
#                      *    freq  length
#                      |    |       |
#                    [tri~         ]
#                      |
--decl
inp(3)
outp(1)
mem(1)=800
mem(2)=0.1
--code
mem(0) = new Wave("triangle",mem(1),mem(2))
out0(0)
saw~
14
# [saw~]  outputs a sawtooth wave
#       
#                      *    freq  length
#                      |    |       |
#                    [saw~         ]
#                      |
--decl
inp(3)
outp(1)
mem(1)=800
mem(2)=0.1
--code
mem(0) = new Wave("sawtooth",mem(1),mem(2))
out0(0)
env~~
12
# [env~~]  set enveloppe of wave
#       
#                      w    a  s  r
#                      |    |   |  |
#                    [env~~         ]
#                      |
--decl
inp(4)
outp(1)
--code
mem(0).SetEnvelope(mem(1),mem(2),mem(3))
out0(0)
vib~~
12
# [vib~~]  set sine lfo on wave
#       
#                      w    f  w  
#                      |    |   | 
#                    [vib~~        ]
#                      |
--decl
inp(3)
outp(1)
--code
mem(0).SetVibrato(mem(1),mem(2))
out0(0)
del~
11
# [del~]  pass delay parameters on audio
#       
#                      
#                      |    |    | 
#                    [del~        ]
#                      
--decl
inp(4)
outp(0)
--code
SetDelay(mem(1),mem(2),mem(3))
~~
11
# [~~] set main volume
#       
#                      
#                      |   
#                    [~~]
#      
--decl
inp(1)
outp(0)
--code
SetVolume(mem(0))
osc~~
11
# [osc~~] play wave
#        
#                      *    
#                      |   
#                    [osc~~]
#                      |
--decl
inp(1)
outp(0)
--code
PlayWave(mem(0))
lerp
11
# [lerp] lerp a value between min and max 
#                *      mn mx  r
#                |      |    |     |
#              [lerp                ]
#                |
--decl
inp(4)
outp(1)
--code
mem(0) = Math.abs(mem(1)-mem(2)) * mem(3)
out0(0)
tab
15
# a tab just an array that can be displayed and set by interacting
#                              *  o  st
#                              |  |  |
#                              [tab  ] 
#                              |
#
--decl
inp(3)
outp(1)
memset(4)
mem(3)=new Array(50).fill(0);
--code
mem(3)[mem(2)] = mem(0)
mem(0) = mem(3)[mem(1)]
out0(0)
graph
17
# 2-dim tab that can be displayed and set by interacting
#                              *  xo   yo xi   yi
#                              |  |    |    |    | 
#                              [graph             ] 
#                              |  
#
--decl
inp(5)
outp(1)
memset(6)
mem(5)=new Array()
var i
for (i=0; i<50;i++){ mem(5).push(new Array(50).fill(0)); }
--code
mem(5)[mem(3)][mem(4)] = mem(0)
mem(0) = mem(5)[mem(1)][mem(2)]
out0(0)
square
12
# [square] stroke a square
#       
#                *  x   y  s
#                |  |   |   |
#               [square       ]
#                |
#
--decl
inp(4); outp(1)
--code
StrokeSquare(mem(1),mem(2), mem(3))
out0(0)
squarefill
12
# [squarefill] fill a square
#       
#                *  x   y  s
#                |  |   |   |
#               [squarefill      ]
#                |
#
--decl
inp(4); outp(1)
--code
FillSquare(mem(1),mem(2), mem(3))
out0(0)
rect
12
# [rect] stroke a rect
#       
#                *  x   y  w  h
#                |  |   |   |   |
#               [rect            ]
#                |
#
--decl
inp(5); outp(1)
--code
StrokeRect(mem(1),mem(2), mem(3), mem(4))
out0(0)
rectfill
12
# [rectfill] fill a rect
#       
#                *  x   y  w  h
#                |  |   |   |   |
#               [rectfill         ]
#                |
#
--decl
inp(5); outp(1)
--code
FillRect(mem(1),mem(2), mem(3), mem(4))
out0(0)
circle
12
# [circle] stroke a circle
#       
#                *  x   y  s
#                |  |   |   |
#               [circle       ]
#                |
#
--decl
inp(4); outp(1)
--code
StrokeCircle(mem(1),mem(2), mem(3))
out0(0)
circlefill
12
# [circlefill] fill a circle
#       
#                *  x   y  s
#                |  |   |   |
#               [circlefill       ]
#                |
#
--decl
inp(4); outp(1)
--code
FillCircle(mem(1),mem(2), mem(3))
out0(0)
line
12
# [line] draw a line
#       
#                *  x   y  x1  y1
#                |  |   |   |   |
#               [line             ]
#                |
#
--decl
inp(5); outp(1)
--code
DrawLine(mem(1),mem(2), mem(3), mem(4))
out0(0)
arc
12
# [arc] stroke a arc
#       
#                *  x   y  r   a
#                |  |   |   |   |
#               [arc            ]
#                |
#
--decl
inp(5); outp(1)
--code
StrokeArc(mem(1),mem(2), mem(3), mem(4))
out0(0)
arcfill
12
# [arcfill] fill a arc
#       
#                *  x   y  r   a
#                |  |   |   |   |
#               [arcfill             ]
#                |
#
--decl
inp(5); outp(1)
--code
FillArc(mem(1),mem(2), mem(3), mem(4))
out0(0)
$
9
#     [$] Bang memory 1
#                      | |
#                    [$  ]
#                      |
--decl
inp(2)
outp(1)
--code
out0(1)
neg
6
--decl
inp(1)
outp(1)
--code
mem(0) = -mem(0)
out0(0)
abs
6
--decl
inp(1)
outp(1)
--code
mem(0) = Math.abs(mem(0))
out0(0)
pi
7
# Output pi
--decl
inp(1)
outp(1)
--code
mem(0) = Math.PI
out0(0)
blocknonce
14
# [blocknonce] output nonce of a block
#	        
#
#            block 
#              |    
#         [blocknonce] 
#              |
--decl
inp(1)
outp(1)
--code
if ( mem(0).timestamp != 'undefined'){Network.SetInternalBlock(mem(0));}
mem(0) = Network.GetBlockNonce();
out0(0)
blockprehash
14
# [blockprehash] output previous hash of block
#	        
#
#            block 
#              |    
#         [blockprehash] 
#              |
--decl
inp(1)
outp(1)
--code
if ( mem(0).timestamp != 'undefined'){Network.SetInternalBlock(mem(0));}
mem(0) = Network.GetBlockPreviousHash();
out0(0)
blocktx
15
# [blocktx] output address of a block transactions 
#               at index
#	        
#
#            block   index
#              |       |
#         [blocktx] 
#              |
--decl
inp(2)
outp(1)
--code
if ( mem(0).timestamp != 'undefined'){Network.SetInternalBlock(mem(0));}
mem(0) = Network.GetBlockTransactionAddress(mem(1));
out0(0)
blockgas
14
# [blockgas] output gas used inside block
#	        
#
#            block 
#              |    
#         [blockgas] 
#              |
--decl
inp(1)
outp(1)
--code
if ( mem(0).timestamp != 'undefined'){Network.SetInternalBlock(mem(0));}
mem(0) = Network.GetBlockGasUsed();
out0(0)
blocksize
14
# [blocksize] output byte length of block
#	        
#
#            block 
#              |    
#         [blocksize] 
#              |
--decl
inp(1)
outp(1)
--code
if ( mem(0).timestamp != 'undefined'){Network.SetInternalBlock(mem(0));}
mem(0) = Network.GetBlockBytesSize();
out0(0)
tx
13
# [tx] output transaction from address
#	        
#
#           addr
#           |    
#         [tx ] 
#           |
--decl
inp(1)
outp(1)
--code
mem(0) = await Network.LoadTransaction(mem(0));
out0(0)
txhash
13
# [txhash] output hash of transaction
#	        
#
#          tx
#          |    
#         [txhash] 
#          |
--decl
inp(1)
outp(1)
--code
mem(0) = await Network.GetTransactionHash();
out0(0)
txgas
13
# [txgas] output gas used for this transaction
#	        
#
#          tx
#          |    
#         [txgas] 
#          |
--decl
inp(1)
outp(1)
--code
mem(0) = await Network.GetTransactionGasUsed();
out0(0)
txprice
13
# [txprice] output gas price when transaction validated
#	        
#
#          tx
#          |    
#         [txgas] 
#          |
--decl
inp(1)
outp(1)
--code
mem(0) = await Network.GetTransactionGasPrice();
out0(0)
txcreator
13
# [txcreator] output address of transaction creator
#	        
#
#          tx
#          |    
#         [txcreator] 
#          |
--decl
inp(1)
outp(1)
--code
mem(0) = await Network.GetTransactionAccountAddr();
out0(0)
loadcontract
0
storagesize
13
# [storagesize] output number of variables inside
#	         smartcontract
#
#           *
#           |    
#         [storagesize] 
#           |
--decl
inp(1)
outp(1)
--code
mem(0) = Network.GetStorageLength();
out0(0)
contractaddr
13
# [contractaddr] output address of a contract
#	        
#
#           *
#           |    
#         [contractaddr] 
#           |
--decl
inp(1)
outp(1)
--code
mem(0) = Network.GetContractAddress();
out0(0)
storage
18
# [storage] output value of a smartcontract at address and 
#               name of the variable 
#	        
#
#            index 
#            |    
#         [storage  ] 
#            |     |
--decl
inp(1)
outp(2)
memset(3)
--code
mem(3) = mem(0)
mem(0) = await Network.GetStorageKeyAtIndex(mem(3));
mem(1) = await Network.GetStorageValueAtIndex(mem(3));
out1(1)
out0(0)
gasprice
13
# [gasprice] output current gas price of ethereum 
#	       network
#
#           * 
#           |    
#         [gasprice] 
#           |
--decl
inp(1)
outp(1)
--code
mem(0) = await Network.GetAverageGasPrice();
out0(0)
1
default
13
1657715670830
knob
default
114
99
1
1
1657715682282
0
1
12.777777777777777
1657715675088
knob
default
183
99
1
1
1657715686289
0
1
57.77777777777777
1657715682282
* 2
default
143
188
1
2
1657715702314
0
1657715702314
1
0
1657715686289
* 2
default
220
186
1
2
1657715702314
2
1657715702314
0
0
1657715702314
pix
default
172
249
1
0
0
1657715731160
slider
default
439
85
1
2
1657715760945
0
1657715760945
1
1
112
1657715735382
slider
default
475
86
1
2
1657715760945
0
1657715760945
2
1
80
1657715741079
slider
default
511
84
1
2
1657715760945
0
1657715760945
3
1
94
1657715760945
color
default
454
225
1
1
1657715781073
0
0
1657715781073
switch
default
553
237
1
1
1657715787569
0
2
112
1
1657715787569
fill
default
631
225
1
0
0
1657715810497
pen
default
328
194
1
0
0
1657715816544
knob
default
310
91
1
2
1657715810497
0
1657715810497
1
1
13.333333333333334
1
default
13
1657715670830
1657715682282
1657715686289
1657715702314
1657715731160
1657715735382
1657715760945
1657715787569
1657715675088
1657715741079
1657715816544
1657715810497
1657715781073
