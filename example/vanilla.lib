96
bang
11
# [bang] pass value when clicked 
#                      |
#                    [bang]
#                      |
--decl
inp(1); outp(1)
--code
out0(0)
#df  Pass a value when user click on it
#i0  Call
#o0 Out
clock
16
# [clock] output its message after one second
#         
#                     *   
#                     |     
#                [ clock  ]
#                     |
--decl
inp(1)
outp(1)
--code
await wait(1000)
out0(0)
#
#df Pass a value one second later
#i0  Call
#o0 Out
color
20
# [color] set color for [pix] [fill] 
#            and other graphics box
#
#                  *  r  g b
#                  |  |  |  |
#                [   color  ]
#                  |                  
--decl
inp(4)
outp(1)
--code
OutputCanvas.SetColor(mem(1),mem(2),mem(3))
out0(0)
#
#df Set color for next graphic commands
#i0 Call
#i1 Set red value between [0-255]
#i2 Set green value between [0-255]
#i3 Set blue value between [0-255]
#o0 Out
fill
15
# [fill] clear display with current color 
#        
#                      |
#                    [fill]
#                      |                      
--decl
inp(1)
outp(1)
--code
OutputCanvas.Fill()
out0(0)
#
#df Fill the screen with current color
#i0 Call
#o0 Out
inc
17
# [inc] increment its memory every time 
#        it is triggered
#                          set
#                      |  |
#                    [inc  ]
#                      |
--decl
inp(2)
outp(1)
memset(2)
--code
mem(1)+=1;
out0(1);
#df Increment number each call 
#i0 Call
#i1 Set number
#o0 Out
log
12
# [log] print its memory to browser
#         console
#
#                      |
#                    [log]
#                      
--decl
inp(1);outp(0);
--code
console.log(mem(0))
#df  Output value to browser console
#i0  Call
pix
16
# [pix] print a pixel on screen at position x and y
#       
#                *  x   y
#                |  |   |
#               [pix      ]
#                |
#
--decl
inp(3); outp(1)
--code
OutputCanvas.SetPixel(mem(1),mem(2))
#df Print a pixel on screen
#i0 Call
#i1 Set x position
#i2 Set y position
#o0 Out
pen
18
# [pen] set resolution of screen pixel 
#          printing command
#
#                  *  res 
#                  |   |   
#               [pen    ]
#                |
#
--decl
inp(2)
outp(1)
--code
ScreenCanvas.SetPenWidth(mem(1))
out0(0)
#df Set size for next pixels and lines graphics command
#i0 Call
#i1 Set size
#o0 Out
pipe
17
# [pipe] output its message after a certain time
#         time set in input#2 is in ms
#                 *   time
#                 |     |
#                [ pipe  ]
#                 |
--decl
inp(2)
outp(1)
mem(1)=1000
--code
await wait(mem(1))
out0(0)
#df Pass value after specific amount of time
#i0 Call
#i1 Set delay as milliseconds
#o0 Out
slider
8
# [slider] outputs integer with
#             special interaction
--decl
inp(1); outp(1);
--code
out0(0)
#i0 Call
#o0 Out
knob
9
# [knob] outputs integer with
#             special interaction
--decl
inp(1)
outp(1)
--code
out0(0)
#i0 Call
#o0 Out
number
9
# [number] outputs integer with
#             a special display
--decl
inp(1)
outp(1)
--code
out0(0)
#i0 Call
#o0 Out
floor
14
# [floor] round a value to its lowest 
#
#                      |
#                    [floor]
#                      |
--decl
inp(1)
outp(1)
--code
mem(0) = Math.floor(mem(0))
out0(0)
#df Round value to its lowest integer
#i0 Call
#o0 Out
/
16
# [ / ] divide a number with
#       divider pass in second entry
#
#	          q   d
#                      |  |
#                    [ /   ]
#                      |
--decl
inp(2); outp(1);
--code
mem(0) /= mem(1)
out0(0)
#df Divide value
#i0 Set quotient and Call 
#i1 Set divider
#o0 Out
switch
13
# [switch] pass or block routine
#              on click, user can set to 0 or I
#	          
#                      |   
#                    [switch]
#                      |
--decl
inp(2)
outp(1)
--code
if (mem(1)==0){out0(0);}
#i0 Call
#o0 Out
rand
23
# [rand]  out a random number 
#            range can be set by passing
#            minimum value at entry 1
#            maximum value at entry 2
#
#                  *  m   mx
#                  |   |   |
#                [rand     ]
#                  |
--decl
inp(3)
outp(1)
mem(1)=0
mem(2)=200
--code
mem(0) = Math.random() * (mem(2)-mem(1))+ mem(1)
mem(0) = Math.floor(mem(0))
out0(0)
#df Output a random number
#i0 Call
#i1 Set minimum
#i2 Set maximum
#o0 Out
metro
0
+
9
--decl
inp(2); outp(1);
--code
mem(0) += mem(1)
out0(0)
#df Add two numbers
#i0 Set first number and call 
#i1 Set second number 
#o0 Out
-
9
--decl
inp(2); outp(1);
--code
mem(0) -= mem(1)
out0(0)
#df Substract two numbers
#i0 Set first number and call 
#i1 Set second number 
#o0 Out
<
8
--decl
inp(2); outp(2);
--code
if ( mem(0) < mem(1) ){ out0(0);} else{ out1(0)}
#df Out left if number below value, else out right
#i0 Call 
#i1 Set value to compare
#o0 Out
>
8
--decl
inp(2); outp(2);
--code
if ( mem(0) > mem(1) ){ out0(0);}else{ out1(0)}
#df Out left if number above value, else out right
#i0 Call 
#i1 Set value to compare
#o0 Out
*
9
--decl
inp(2); outp(1);
--code
mem(0) *= mem(1)
out0(0)
#df Multiply two numbers
#i0 Set first number and call 
#i1 Set second number 
#o0 Out
>=
8
--decl
inp(2); outp(2);
--code
if ( mem(0) >= mem(1) ){ out0(0);}else{ out1(0)}
#df Out left if number above or equals value, else out right
#i0 Call 
#i1 Set value to compare
#o0 Out
<=
8
--decl
inp(2); outp(2);
--code
if ( mem(0) <= mem(1) ){ out0(0);}else{ out1(0)}
#df Out left if number below or equals value, else out right
#i0 Call 
#i1 Set value to compare
#o0 Out
==
8
--decl
inp(2); outp(2);
--code
if ( mem(0) == mem(1) ){ out0(0);}else{ out1(0)}
#df Out left if number equals value, else out right
#i0 Call 
#i1 Set value to compare
#o0 Out
zero
13
# [zero] output 0
#        
#                      |
#                    [zero]
#                      |
--decl
inp(1); outp(1)
--code
mem(0) =0
out0(0)
#df Out zero
#i0 Call 
#o0 Out
one
13
# [one] output 1
#        
#                      |
#                    [one]
#                      |
--decl
inp(1); outp(1)
--code
mem(0) =1
out0(0)
#df Out one
#i0 Call 
#o0 Out
hashmux32
77
# [hashmux32] output 32 values between 0 and 255
#                     from a hash string
#
#             |
#         [hashmux32                               ]
#             ||||||||||||||||||||||||||||||||
--decl
inp(1)
outp(32)
memset(32)
--code
mem(0) = HashMux32(mem(0))
mem(1) = mem(0)[1]
mem(2) = mem(0)[2]
mem(3) = mem(0)[3]
mem(4) = mem(0)[4]
mem(5) = mem(0)[5]
mem(6) = mem(0)[6]
mem(7) = mem(0)[7]
mem(8) = mem(0)[8]
mem(9) = mem(0)[9]
mem(10) = mem(0)[10]
mem(11) = mem(0)[11]
mem(12) = mem(0)[12]
mem(13) = mem(0)[13]
mem(14) = mem(0)[14]
mem(15) = mem(0)[15]
mem(16) = mem(0)[16]
mem(17) = mem(0)[17]
mem(18) = mem(0)[18]
mem(19) = mem(0)[19]
mem(20) = mem(0)[20]
mem(21) = mem(0)[21]
mem(22) = mem(0)[22]
mem(23) = mem(0)[23]
mem(24) = mem(0)[25]
mem(26) = mem(0)[26]
mem(27) = mem(0)[27]
mem(28) = mem(0)[28]
mem(29) = mem(0)[29]
mem(30) = mem(0)[30]
mem(31) = mem(0)[31]
mem(0) = mem(0)[0]
out0(0)
out1(1)
out2(2)
out3(3)
out4(4)
out5(5)
out6(6)
out7(7)
out8(8)
out9(9)
out10(10)
out11(11)
out12(12)
out13(13)
out14(14)
out15(15)
out16(16)
out17(17)
out18(18)
out19(19)
out20(20)
out21(21)
out22(22)
out23(23)
out24(24)
out25(25)
out26(26)
out27(27)
out28(28)
out29(29)
out30(30)
out31(31)
#df Out 32 values between [0-255] from a hash
#i0 Hash
int
7
--decl
inp(1)
outp(1)
--code
mem(0)=parseInt(mem(0))
out0(0)
#df Convert string to integer
str
0
loadblock
17
# [loadblock] load a block at index in its internal memory 
#             then outputs it
#
#               index
#            |    |
#         [loadblock] 
#              |
--decl
inp(2)
outp(1)
--code
mem(0) = await Network.LoadBlockAtIndex(mem(1))
out0(0)
#df Output a blockchain block object
#i0 Call 
#i1 Set blockchain block index
#o0 Out
chainheight
15
# [chainheight] outputs blockchain length when triggered
#               as number
#
#               |
#         [chainheight]
#               |
--decl
inp(1)
outp(1)
--code
mem(0) = await Network.GetBlockchainLength()
out0(0)
#df Ouput current blockchain height
#i0 Call 
#o0 Out
blockhash
16
# [blockhash] output hash of a block as a string
#
#            block 
#              |    
#         [blockhash] 
#              |
--decl
inp(1)
outp(1)
--code
if ( mem(0).hash != 'undefined'){Network.SetInternalBlock(mem(0));}
mem(0) = Network.GetBlockHash();
out0(0)
#df Output hash of a blockchain block object
#i0 Block
#o0 Out
blocktime
17
# [blocktime] output timestamp of a block as UNIX 
#	      timestamp
#
#            block 
#              |    
#         [blocktime] 
#              |
--decl
inp(1)
outp(1)
--code
if ( mem(0).timestamp != 'undefined'){Network.SetInternalBlock(mem(0));}
mem(0) = Network.GetBlockTimeStamp();
out0(0)
#df Output unix timestamp of a blockchain block object
#i0 Block
#o0 Out
blockheight
17
# [blockheight] output height of a block
#	        
#
#            block 
#              |    
#         [blockheight] 
#              |
--decl
inp(1)
outp(1)
--code
if ( mem(0).timestamp != 'undefined'){Network.SetInternalBlock(mem(0));}
mem(0) = Network.GetBlockIndex();
out0(0)
#df Output height of a blockchain block object
#i0 Block
#o0 Out
hashlerp
15
# [hashlerp] lerp hash value between 0 and 1
#                
#
#               |
#         [hashlerp  ]
#               |
--decl
inp(1)
outp(1)
--code
mem(0) = LerpHash(mem(0))
out0(0)
#df Output a value between [0-1] from a hash
#i0 Hash
#o0 Out
sel
0
gate
15
# [gate]  pass or block routine 
#            if second input above 0
#	          
#                      |    |
#                    [gate ]
#                      |   
--decl
inp(2)
outp(1)
--code
if (mem(1)==0){out0(0);}
#df Pass value if number equal zero
#i0 Call 
#i1 Set number
#o0 Out
onload
10
# [onload] bang when project open
#                      
#                    [onload]
#                      |
--decl
inp(0); outp(1)
--code
out0(0)
#df Call when project load
#o0 Out
dec
17
# [dec] decrement its memory every time 
#        it is triggered
#                          set
#                      |  |
#                    [dec  ]
#                      |
--decl
inp(2)
outp(1)
memset(2)
--code
mem(1)-=1;
out0(1);
#df Decrement number each call 
#i0 Call
#i1 Set number
#o0 Out
sin~
19
# [sin~]  outputs a sine wave
#        
#                      *    freq  length
#                      |    |       |
#                    [sin~         ]
#                      |
--decl
inp(3)
outp(1)
mem(1)=800
mem(2)=0.1
--code
mem(0) = new Wave("sine",mem(1),mem(2))
out0(0)
#df Ouput a sine wave
#i0 Call
#i1 Set frequency
#i2 Set tone length in milliseconds
#o0 Out
sqr~
19
# [sqr~]  outputs a square wave
#        
#                      *    freq  length
#                      |    |       |
#                    [sqr~         ]
#                      |
--decl
inp(3)
outp(1)
mem(1)=800
mem(2)=0.1
--code
mem(0) = new Wave("square",mem(1),mem(2))
out0(0)
#df Ouput a square wave
#i0 Call
#i1 Set frequency
#i2 Set tone length in milliseconds
#o0 Out
tri~
19
# [tri~]  outputs a triangle wave
#        
#                      *    freq  length
#                      |    |       |
#                    [tri~         ]
#                      |
--decl
inp(3)
outp(1)
mem(1)=800
mem(2)=0.1
--code
mem(0) = new Wave("triangle",mem(1),mem(2))
out0(0)
#df Ouput a triangle wave
#i0 Call
#i1 Set frequency
#i2 Set tone length in milliseconds
#o0 Out
saw~
19
# [saw~]  outputs a sawtooth wave
#       
#                      *    freq  length
#                      |    |       |
#                    [saw~         ]
#                      |
--decl
inp(3)
outp(1)
mem(1)=800
mem(2)=0.1
--code
mem(0) = new Wave("sawtooth",mem(1),mem(2))
out0(0)
#df Ouput a sawtooth wave
#i0 Call
#i1 Set frequency
#i2 Set tone length in milliseconds
#o0 Out
env~~
18
# [env~~]  set enveloppe of wave
#       
#                      w    a  s  r
#                      |    |   |  |
#                    [env~~         ]
#                      |
--decl
inp(4)
outp(1)
--code
mem(0).SetEnvelope(mem(1),mem(2),mem(3))
out0(0)
#df Set enveloppe of a sound wave
#i0 Sound wave
#i1 Set attack length in milliseconds
#i2 Set sustain length in milliseconds
#i3 Set release length in milliseconds
#o0 Out
vib~~
17
# [vib~~]  set sine lfo on wave
#       
#                      w    f  w  
#                      |    |   | 
#                    [vib~~        ]
#                      |
--decl
inp(3)
outp(1)
--code
mem(0).SetVibrato(mem(1),mem(2))
out0(0)
#df Apply vibrato to a sound wave
#i0 Sound wave
#i1 Set frequency modulation
#i2 Set wet value
#o0 Out
del~
16
# [del~]  pass delay parameters on audio
#       
#                      
#                      |    |    | 
#                    [del~        ]
#                      
--decl
inp(4)
outp(0)
--code
SetDelay(mem(1),mem(2),mem(3))
#df Set delay FX
#i0 Call
#i1 Set delay time
#i2 Set delay amount
#o0 Out
~~
14
# [~~] set main volume
#       
#                      
#                      |   
#                    [~~]
#      
--decl
inp(1)
outp(0)
--code
SetVolume(mem(0))
#df Set main volume
#i0  Call
#o0 Out
osc~~
14
# [osc~~] play wave
#        
#                      *    
#                      |   
#                    [osc~~]
#                      |
--decl
inp(1)
outp(0)
--code
PlayWave(mem(0))
#df Play sound wave
#i0 Sound wave
#o0 Out
lerp
15
# [lerp] lerp a value between min and max 
#                *      mn mx  r
#                |      |    |     |
#              [lerp                ]
#                |
--decl
inp(4)
outp(1)
--code
mem(0) = Math.abs(mem(1)-mem(2)) * mem(3)
out0(0)
#df Out value between two numbers
#i1 Set minimum range
#i2 Set maximum range
#i3 Set cursor range
tab
17
# a tab just an array that can be displayed and set by interacting
#                              *  o  st
#                              |  |  |
#                              [tab  ] 
#                              |
#
--decl
inp(3)
outp(1)
memset(4)
mem(3)=new Array(50).fill(0);
--code
mem(3)[mem(2)] = mem(0)
mem(0) = mem(3)[mem(1)]
out0(0)
#i1 Read index
#i2 Write index
graph
21
# 2-dim tab that can be displayed and set by interacting
#                              *  xo   yo xi   yi
#                              |  |    |    |    | 
#                              [graph             ] 
#                              |  
#
--decl
inp(5)
outp(1)
memset(6)
mem(5)=new Array()
var i
for (i=0; i<50;i++){ mem(5).push(new Array(50).fill(0)); }
--code
mem(5)[mem(3)][mem(4)] = mem(0)
mem(0) = mem(5)[mem(1)][mem(2)]
out0(0)
#i1 Read X-index
#i2 Read Y-index
#i3 Write X-index
#i4 Write Y-index
square
16
# [square] stroke a square
#       
#                *  x   y  s
#                |  |   |   |
#               [square       ]
#                |
#
--decl
inp(4); outp(1)
--code
OutputCanvas.StrokeSquare(mem(1),mem(2), mem(3))
out0(0)
#df Stroke a square
#i1 Set x position
#i2 Set y position
#i3 Set dimension
squarefill
16
# [squarefill] fill a square
#       
#                *  x   y  s
#                |  |   |   |
#               [squarefill      ]
#                |
#
--decl
inp(4); outp(1)
--code
OutputCanvas.FillSquare(mem(1),mem(2), mem(3))
out0(0)
#df Fill a square
#i1 Set x position
#i2 Set y position
#i3 Set dimension
rect
17
# [rect] stroke a rect
#       
#                *  x   y  w  h
#                |  |   |   |   |
#               [rect            ]
#                |
#
--decl
inp(5); outp(1)
--code
OutputCanvas.StrokeRect(mem(1),mem(2), mem(3), mem(4))
out0(0)
#df Stroke a rectangle
#i1 Set x position
#i2 Set y position
#i3 Set rectangle width
#i4 Set rectangle height
rectfill
17
# [rectfill] fill a rect
#       
#                *  x   y  w  h
#                |  |   |   |   |
#               [rectfill         ]
#                |
#
--decl
inp(5); outp(1)
--code
OutputCanvas.FillRect(mem(1),mem(2), mem(3), mem(4))
out0(0)
#df Fill a rectangle
#i1 Set x position
#i2 Set y position
#i3 Set rectangle width
#i4 Set rectangle height
circle
16
# [circle] stroke a circle
#       
#                *  x   y  s
#                |  |   |   |
#               [circle       ]
#                |
#
--decl
inp(4); outp(1)
--code
OutputCanvas.StrokeCircle(mem(1),mem(2), mem(3))
out0(0)
#df Stroke a circle
#i1 Set x position
#i2 Set y position
#i3 Set radius
circlefill
16
# [circlefill] fill a circle
#       
#                *  x   y  s
#                |  |   |   |
#               [circlefill       ]
#                |
#
--decl
inp(4); outp(1)
--code
OutputCanvas.FillCircle(mem(1),mem(2), mem(3))
out0(0)
#df Fill a circle
#i1 Set x position
#i2 Set y position
#i3 Set radius
line
17
# [line] draw a line
#       
#                *  x   y  x1  y1
#                |  |   |   |   |
#               [line             ]
#                |
#
--decl
inp(5); outp(1)
--code
OutputCanvas.DrawLine(mem(1),mem(2), mem(3), mem(4))
out0(0)
#df Draw a line
#i1 Set x starting position
#i2 Set y starting position
#i1 Set x ending position
#i2 Set y ending position
arc
17
# [arc] stroke a arc
#       
#                *  x   y  r   a
#                |  |   |   |   |
#               [arc            ]
#                |
#
--decl
inp(5); outp(1)
--code
OutputCanvas.StrokeArc(mem(1),mem(2), mem(3), mem(4))
out0(0)
#df Stroke a arc
#i1 Set x position
#i2 Set y position
#i3 Set radius
#i4 Set atans
arcfill
17
# [arcfill] fill a arc
#       
#                *  x   y  r   a
#                |  |   |   |   |
#               [arcfill             ]
#                |
#
--decl
inp(5); outp(1)
--code
OutputCanvas.FillArc(mem(1),mem(2), mem(3), mem(4))
out0(0)
#df Fill a arc
#i1 Set x position
#i2 Set y position
#i3 Set radius
#i4 Set atans
$
11
#     [$] Bang memory 1
#                      | |
#                    [$  ]
#                      |
--decl
inp(2)
outp(1)
--code
out0(1)
#df Output a stored value
#i1 Set value
neg
7
--decl
inp(1)
outp(1)
--code
mem(0) = -mem(0)
out0(0)
#df Negate a value
abs
7
--decl
inp(1)
outp(1)
--code
mem(0) = Math.abs(mem(0))
out0(0)
#df Output absolute vallue
pi
8
# Output pi
--decl
inp(1)
outp(1)
--code
mem(0) = Math.PI
out0(0)
#df Output pi
blocknonce
16
# [blocknonce] output nonce of a block
#	        
#
#            block 
#              |    
#         [blocknonce] 
#              |
--decl
inp(1)
outp(1)
--code
if ( mem(0).timestamp != 'undefined'){Network.SetInternalBlock(mem(0));}
mem(0) = Network.GetBlockNonce();
out0(0)
#df Output nonce of a blockchain block
#i0 Block 
blockprehash
16
# [blockprehash] output previous hash of block
#	        
#
#            block 
#              |    
#         [blockprehash] 
#              |
--decl
inp(1)
outp(1)
--code
if ( mem(0).timestamp != 'undefined'){Network.SetInternalBlock(mem(0));}
mem(0) = Network.GetBlockPreviousHash();
out0(0)
#df Output previous hash of a blockchain block
#i0 Block 
blocktx
18
# [blocktx] output address of a block transactions 
#               at index
#	        
#
#            block   index
#              |       |
#         [blocktx] 
#              |
--decl
inp(2)
outp(1)
--code
if ( mem(0).timestamp != 'undefined'){Network.SetInternalBlock(mem(0));}
mem(0) = Network.GetBlockTransactionAddress(mem(1));
out0(0)
#df Output address of a block transaction
#i0 Block
#i1 Index
blockgas
16
# [blockgas] output gas used inside block
#	        
#
#            block 
#              |    
#         [blockgas] 
#              |
--decl
inp(1)
outp(1)
--code
if ( mem(0).timestamp != 'undefined'){Network.SetInternalBlock(mem(0));}
mem(0) = Network.GetBlockGasUsed();
out0(0)
#df Output gas used inside blockchain block
#i0 Block
blocksize
16
# [blocksize] output byte length of block
#	        
#
#            block 
#              |    
#         [blocksize] 
#              |
--decl
inp(1)
outp(1)
--code
if ( mem(0).timestamp != 'undefined'){Network.SetInternalBlock(mem(0));}
mem(0) = Network.GetBlockBytesSize();
out0(0)
#df Output byte size of a blockchain block
#i0 Block
tx
15
# [tx] output transaction from address
#	        
#
#           addr
#           |    
#         [tx ] 
#           |
--decl
inp(1)
outp(1)
--code
mem(0) = await Network.LoadTransaction(mem(0));
out0(0)
#df Output a transaction from address
#i0 address
txhash
15
# [txhash] output hash of transaction
#	        
#
#          tx
#          |    
#         [txhash] 
#          |
--decl
inp(1)
outp(1)
--code
mem(0) = await Network.GetTransactionHash();
out0(0)
#df Output hash of a transaction
#i0 blockchain transaction
txgas
15
# [txgas] output gas used for this transaction
#	        
#
#          tx
#          |    
#         [txgas] 
#          |
--decl
inp(1)
outp(1)
--code
mem(0) = await Network.GetTransactionGasUsed();
out0(0)
#df Output gas used for a transaction
#i0 blockchain transaction
txprice
15
# [txprice] output gas price when transaction validated
#	        
#
#          tx
#          |    
#         [txgas] 
#          |
--decl
inp(1)
outp(1)
--code
mem(0) = await Network.GetTransactionGasPrice();
out0(0)
#df Output gas price spent for blockchain transaction
#i0 blockchain transaction
txcreator
15
# [txcreator] output address of transaction creator
#	        
#
#          tx
#          |    
#         [txcreator] 
#          |
--decl
inp(1)
outp(1)
--code
mem(0) = await Network.GetTransactionAccountAddr();
out0(0)
#df Output wallet address of a blockchain transaction
#i0 blockchain transaction
loadcontract
0
storagesize
15
# [storagesize] output number of variables inside
#	         smartcontract
#
#           *
#           |    
#         [storagesize] 
#           |
--decl
inp(1)
outp(1)
--code
mem(0) = Network.GetStorageLength();
out0(0)
#df Output number of variables inside a smartcontract
#i0 Smartcontract object
contractaddr
15
# [contractaddr] output address of a contract
#	        
#
#           *
#           |    
#         [contractaddr] 
#           |
--decl
inp(1)
outp(1)
--code
mem(0) = Network.GetContractAddress();
out0(0)
#df Output blockchain contract address
#i0 Smartcontract object
storage
20
# [storage] output value of a smartcontract at address and 
#               name of the variable 
#	        
#
#            index 
#            |    
#         [storage  ] 
#            |     |
--decl
inp(1)
outp(2)
memset(3)
--code
mem(3) = mem(0)
mem(0) = await Network.GetStorageKeyAtIndex(mem(3));
mem(1) = await Network.GetStorageValueAtIndex(mem(3));
out1(1)
out0(0)
#df Output value stored inside smartcontract
#i0 Key index
gasprice
13
# [gasprice] output current gas price of ethereum 
#	       network
#
#           * 
#           |    
#         [gasprice] 
#           |
--decl
inp(1)
outp(1)
--code
mem(0) = await Network.GetAverageGasPrice();
out0(0)
num2mutez
5
--decl
inp(1); outp(1)
--code
mem(0) = StorageValueToMutez(mem(0))
out0(0)
num2tez
5
--decl
inp(1); outp(1)
--code
mem(0) = StorageValueToTez(mem(0))
out0(0)
mutez2tez
5
--decl
inp(1); outp(1)
--code
mem(0) = MutezToTez(mem(0))
out0(0)
tez2mutez
5
--decl
inp(1); outp(1)
--code
mem(0) = TezToMutez(mem(0))
out0(0)
wei2ether
5
--decl
inp(1); outp(1)
--code
mem(0) = WeiToEther(mem(0))
out0(0)
ether2wei
5
--decl
inp(1); outp(1)
--code
mem(0) = EtherToWei(mem(0))
out0(0)
gwei2wei
5
--decl
inp(1); outp(1)
--code
mem(0) = GweiToWei(mem(0))
out0(0)
ether2doll
5
--decl
inp(1); outp(1)
--code
mem(0) = EtherToDollar(mem(0))
out0(0)
ether2eur
5
--decl
inp(1); outp(1)
--code
mem(0) = EtherToEuro(mem(0))
out0(0)
msg
11
# [msg] pass a chain of characters.
#           Change the chain of characters as you do it for renaming blocks.
#                      |
#                    [msg]
#                      |
--decl
inp(1); outp(1);memset(2)
mem(1) = 'hello world'
--code
out0(1)
#df  Pass a chain of characters when user click on it
supermetaparam
9
--decl
inp(5)
--code
# Code editor
 ide.CodeEditor.SetFont('font'+mem(1),mem(2),'');
 ide.CodeEditor.Draw()
# Block
VisualParameters.BlockBorderWidth = mem(3);
VisualParameters.WireWidth = mem(4);
arr
8
--decl
inp(2)
outp(1)
--code
if (mem(0).length > mem(1)){mem(0)=mem(0)[mem(1)];}
out0(0)
#df Ouput element of an array
#i0 Set index
split
9
--decl
inp(2)
outp(1)
mem(1)=' '
--code
mem(0) = mem(0).split(mem(1))
out0(0)
#df Split chain of character
#i1 Set separator
hz2midi
7
--decl
inp(1)
outp(1)
--code
mem(0) = 12 * (Math.log(mem(0)/220)/Math.log(2)) + 57
out0(0)
#df Output midi value from frequency
midi2hz
7
--decl
inp(1)
outp(1)
--code
mem(0)=440*(Math.pow(2,((mem(0)-69)/12)))
out0(0)
#df Output frequency from midi value
len
7
--decl
inp(1)
outp(1)
--code
mem(0)=mem(0).length
out0(0)
#df Return length of an array
