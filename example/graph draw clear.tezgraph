64
bang
9
# [bang] can trigger output on mouse down 
#        & has visual effect on receiving data
#                      |
#                    [bang]
#                      |
--decl
inp(1); outp(1)
--code
out0(0)
clock
12
# [clock] output its message after one second
#         
#                     *   
#                     |     
#                [ clock  ]
#                     |
--decl
inp(1)
outp(1)
--code
await wait(1000)
out0(0)
color
13
# [color] set color for [pix] [fill] 
#            and other graphics box
#
#                  *  r  g b
#                  |  |  |  |
#                [   color  ]
#                     
--decl
inp(4)
outp(1)
--code
SetColor(mem(1),mem(2),mem(3))
out0(0)
fill
11
# [fill] clear display with current color 
#        
#                      |
#                    [fill]
#                      
--decl
inp(1)
outp(1)
--code
ClearScreen()
out0(0)
inc
13
# [inc] increment its memory every time 
#        it is triggered
#
#                      |  |
#                    [inc  ]
#                      |
--decl
inp(2)
outp(1)
memset(2)
--code
mem(1)+=1;
out0(1);
log
10
# [log] print its memory to browser
#         console
#
#                      |
#                    [log]
#                      
--decl
inp(1);outp(0);
--code
console.log(mem(0))
pix
11
# [pix] print a pixel on screen at position x and y
#       
#                *  x   y
#                |  |   |
#               [pix      ]
#                |
#
--decl
inp(3); outp(1)
--code
SetPixel(mem(1),mem(2))
pen
14
# [pen] set resolution of screen pixel 
#          printing command
#
#                  *  res 
#                  |   |   
#               [pen    ]
#                |
#
--decl
inp(2)
outp(1)
--code
SetPenWidth(mem(1))
out0(0)
pipe
13
# [pipe] output its message after a certain time
#         time set in input#2 is in ms
#                 *   time
#                 |     |
#                [ pipe  ]
#                     |
--decl
inp(2)
outp(1)
mem(1)=1000
--code
await wait(mem(1))
out0(0)
slider
6
# [slider] outputs integer with
#             special interaction
--decl
inp(1); outp(1);
--code
out0(0)
knob
7
# [knob] outputs integer with
#             special interaction
--decl
inp(1)
outp(1)
--code
out0(0)
number
7
# [slider] outputs integer with
#             a special display
--decl
inp(1)
outp(1)
--code
out0(0)
floor
11
# [floor] round a value to its lowest 
#
#                      |
#                    [floor]
#                      |
--decl
inp(1)
outp(1)
--code
mem(0) = Math.floor(mem(0))
out0(0)
/
12
# [ / ] divide a number with
#       divider pass in second entry
#
#	          q   d
#                      |  |
#                    [ /   ]
#                      |
--decl
inp(2); outp(1);
--code
mem(0) /= mem(1)
out0(0)
switch
11
# [switch] pass or block routine
#              on click, user can set to 0 or I
#	          
#                      |   
#                    [switch]
#                      |
--decl
inp(2)
outp(1)
--code
if (mem(1)==0){out0(0);}
rand
18
# [rand]  out a random number 
#            range can be set by passing
#            minimum value at entry 1
#            maximum value at entry 2
#
#                  *  m   mx
#                  |   |   |
#                [rand     ]
#                  |
--decl
inp(3)
outp(1)
mem(1)=0
mem(2)=200
--code
mem(0) = Math.random() * (mem(2)-mem(1))+ mem(1)
mem(0) = Math.floor(mem(0))
out0(0)
metro
7
--decl
inp(2)
outp(1)
mem(1) = 1000
--code
await wait(mem(1))
out0(0) 
+
5
--decl
inp(2); outp(1);
--code
mem(0) += mem(1)
out0(0)
-
5
--decl
inp(2); outp(1);
--code
mem(0) -= mem(1)
out0(0)
<
4
--decl
inp(2); outp(2);
--code
if ( mem(0) < mem(1) ){ out0(0);} else{ out1(0)}
>
4
--decl
inp(2); outp(2);
--code
if ( mem(0) > mem(1) ){ out0(0);}else{ out1(0)}
*
5
--decl
inp(2); outp(1);
--code
mem(0) *= mem(1)
out0(0)
>=
4
--decl
inp(2); outp(2);
--code
if ( mem(0) >= mem(1) ){ out0(0);}else{ out1(0)}
<=
4
--decl
inp(2); outp(2);
--code
if ( mem(0) <= mem(1) ){ out0(0);}else{ out1(0)}
==
4
--decl
inp(2); outp(2);
--code
if ( mem(0) == mem(1) ){ out0(0);}else{ out1(0)}
zero
10
# [zero] output 0
#        
#                      |
#                    [zero]
#                      |
--decl
inp(1); outp(1)
--code
mem(0) =0
out0(0)
one
10
# [one] output 1
#        
#                      |
#                    [one]
#                      |
--decl
inp(1); outp(1)
--code
mem(0) =1
out0(0)
hashmux32
75
# [hashmux32] output 32 values between 0 and 255
#                     from a hash string
#
#             |
#         [hashmux32                               ]
#             ||||||||||||||||||||||||||||||||
--decl
inp(1)
outp(32)
memset(32)
--code
mem(0) = HashMux32(mem(0))
mem(1) = mem(0)[1]
mem(2) = mem(0)[2]
mem(3) = mem(0)[3]
mem(4) = mem(0)[4]
mem(5) = mem(0)[5]
mem(6) = mem(0)[6]
mem(7) = mem(0)[7]
mem(8) = mem(0)[8]
mem(9) = mem(0)[9]
mem(10) = mem(0)[10]
mem(11) = mem(0)[11]
mem(12) = mem(0)[12]
mem(13) = mem(0)[13]
mem(14) = mem(0)[14]
mem(15) = mem(0)[15]
mem(16) = mem(0)[16]
mem(17) = mem(0)[17]
mem(18) = mem(0)[18]
mem(19) = mem(0)[19]
mem(20) = mem(0)[20]
mem(21) = mem(0)[21]
mem(22) = mem(0)[22]
mem(23) = mem(0)[23]
mem(24) = mem(0)[25]
mem(26) = mem(0)[26]
mem(27) = mem(0)[27]
mem(28) = mem(0)[28]
mem(29) = mem(0)[29]
mem(30) = mem(0)[30]
mem(31) = mem(0)[31]
mem(0) = mem(0)[0]
out0(0)
out1(1)
out2(2)
out3(3)
out4(4)
out5(5)
out6(6)
out7(7)
out8(8)
out9(9)
out10(10)
out11(11)
out12(12)
out13(13)
out14(14)
out15(15)
out16(16)
out17(17)
out18(18)
out19(19)
out20(20)
out21(21)
out22(22)
out23(23)
out24(24)
out25(25)
out26(26)
out27(27)
out28(28)
out29(29)
out30(30)
out31(31)
int
1
-
str
1
-
loadblock
13
# [loadblock] load a block at index in its internal memory 
#             then outputs it
#
#               index
#            |    |
#         [loadblock] 
#              |
--decl
inp(2)
outp(1)
--code
mem(0) = await Network.LoadBlockAtIndex(mem(1))
out0(0)
chainheight
12
# [chainheight] outputs blockchain length when triggered
#               as number
#
#               |
#         [chainheight]
#               |
--decl
inp(1)
outp(1)
--code
mem(0) = await Network.GetBlockchainLength()
out0(0)
blockhash
13
# [blockhash] output hash of a block as a string
#
#            block 
#              |    
#         [blockhash] 
#              |
--decl
inp(1)
outp(1)
--code
if ( mem(0).hash != 'undefined'){Network.SetInternalBlock(mem(0));}
mem(0) = Network.GetBlockHash();
out0(0)
blocktime
14
# [blocktime] output timestamp of a block as UNIX 
#	      timestamp
#
#            block 
#              |    
#         [blocktime] 
#              |
--decl
inp(1)
outp(1)
--code
if ( mem(0).timestamp != 'undefined'){Network.SetInternalBlock(mem(0));}
mem(0) = Network.GetTimeStamp();
out0(0)
blockheight
14
# [blockheight] output height of a block
#	        
#
#            block 
#              |    
#         [blockheight] 
#              |
--decl
inp(1)
outp(1)
--code
if ( mem(0).timestamp != 'undefined'){Network.SetInternalBlock(mem(0));}
mem(0) = Network.GetBlockIndex();
out0(0)
hashlerp
12
# [hashlerp] lerp hash value between 0 and 1
#                
#
#               |
#         [hashlerp  ]
#               |
--decl
inp(1)
outp(1)
--code
mem(0) = LerpHash(mem(0))
out0(0)
sel
2
# output 1 or 0 at output if match 
# output count depend of number of stuff 
gate
11
# [gate]  pass or block routine 
#            if second input
#	          
#                      |    |
#                    [gate ]
#                      |   
--decl
inp(2)
outp(1)
--code
if (mem(1)==0){out0(0);}
onload
8
# [onload] bang when project open
#                      
#                    [onload]
#                      |
--decl
inp(0); outp(1)
--code
out0(0)
dec
13
# [dec] decrement its memory every time 
#        it is triggered
#
#                      |  |
#                    [dec  ]
#                      |
--decl
inp(2)
outp(1)
memset(2)
--code
mem(1)-=1;
out0(1);
sin~
12
#
#
#
#
--decl
inp(3)
outp(1)
mem(1)=800
mem(2)=0.1
--code
mem(0) = new Wave("sine",mem(1),mem(2))
out0(0)
sqr~
12
#
#
#
#
--decl
inp(3)
outp(1)
mem(1)=800
mem(2)=0.1
--code
mem(0) = new Wave("square",mem(1),mem(2))
out0(0)
tri~
12
#
#
#
#
--decl
inp(3)
outp(1)
mem(1)=800
mem(2)=0.1
--code
mem(0) = new Wave("triangle",mem(1),mem(2))
out0(0)
saw~
12
#
#
#
#
--decl
inp(3)
outp(1)
mem(1)=800
mem(2)=0.1
--code
mem(0) = new Wave("sawtooth",mem(1),mem(2))
out0(0)
env~~
6
--decl
inp(4)
outp(1)
--code
mem(0).SetEnvelope(mem(1),mem(2),mem(3))
out0(0)
vib~~
6
--decl
inp(3)
outp(1)
--code
mem(0).SetVibrato(mem(1),mem(2))
out0(0)
del~
5
--decl
inp(4)
outp(0)
--code
SetDelay(mem(1),mem(2),mem(3))
~~
5
--decl
inp(1)
outp(0)
--code
SetVolume(mem(0))
osc~~
6
#
--decl
inp(1)
outp(0)
--code
PlayWave(mem(0))
lerp
7
# lerp value set value 0 a num between  0 and max -> mem(1)
--decl
inp(3)
outp(1)
--code
mem(0) = mem(1) * mem(2)
out0(0)
tab
15
# a tab just an array that can be displayed and set by interacting
#                              *  o  st
#                              |  |  |
#                              [tab  ] 
#                              |
#
--decl
inp(3)
outp(1)
memset(4)
mem(3)=new Array(50).fill(0);
--code
mem(3)[mem(2)] = mem(0)
mem(0) = mem(3)[mem(1)]
out0(0)
graph
17
# 2-dim tab that can be displayed and set by interacting
#                              *  xo   yo xi   yi
#                              |  |    |    |    | 
#                              [graph             ] 
#                              |  
#
--decl
inp(5)
outp(1)
memset(6)
mem(5)=new Array()
var i
for (i=0; i<50;i++){ mem(5).push(new Array(50).fill(0)); }
--code
mem(5)[mem(3)][mem(4)] = mem(0)
mem(0) = mem(5)[mem(1)][mem(2)]
out0(0)
square
0
squarefill
0
rect
0
rectfill
0
circle
0
circlefill
0
line
0
arc
0
arcfill
0
$
6
## Bang its memory 1
--decl
inp(2)
outp(1)
--code
out0(1)
neg
6
--decl
inp(1)
outp(1)
--code
mem(0) = -mem(0)
out0(0)
abs
6
--decl
inp(1)
outp(1)
--code
mem(0) = Math.abs(mem(0))
out0(0)
1
default
33
1657575534204
graph
default
136
166
1
1
1657575793897
0
0
1657575571677
zero
default
146
100
1
1
1657575534204
0
0
1657575600545
inc
default
492
142
1
1
1657575655387
0
0
1657575617599
bang
default
490
80
1
2
1657575624792
0
1657575600545
0
0
1657575624792
pipe
default
549
83
1
1
1657575617599
0
0
1657575630687
slider
default
643
70
1
1
1657575624792
1
1
10
1657575639277
/ 10
default
603
245
1
0
0
1657575655387
number
default
472
215
1
6
1657575666308
0
1657576522166
0
1657575571677
0
1657575534204
1
1657633541386
0
1657633541386
0
1
24
1657575666308
> 48
default
474
277
2
1
1657575678298
0
0
0
1657575678298
bang
default
435
336
1
2
1657575698733
0
1657575710024
0
0
1657575698733
inc
default
394
385
1
1
1657575725836
0
0
1657575710024
zero
default
374
267
1
1
1657575600545
1
0
1657575725836
number
default
384
437
1
4
1657575737482
0
1657576526263
0
1657633533622
0
1657575534204
2
1
33
1657575737482
> 48
default
375
499
2
2
1657575742841
0
1657576472492
0
0
0
1657575742841
zero
default
289
428
1
5
1657575698733
1
1657576437848
0
1657576437848
1
1657576437848
2
1657576437848
3
0
1657575793897
> 0
default
126
327
2
1
1657576573997
0
0
0
1657576437848
color
default
516
432
1
1
1657576445966
0
0
1657576445966
fill
default
514
487
1
0
0
1657576472492
bang
default
315
531
1
0
0
1657576509898
pix
default
113
472
1
0
0
1657576522166
* 10
default
226
298
1
1
1657576509898
1
0
1657576526263
* 10
default
219
360
1
1
1657576509898
2
0
1657576573997
* 255
default
52
370
1
4
1657576578434
1
1657576578434
2
1657576578434
3
1657576578434
0
0
1657576578434
color
default
34
431
1
1
1657576509898
0
0
1657576608712
knob
default
688
357
1
2
1657576612524
0
1657576612524
1
1
12.222222222222221
1657576612524
pen
default
701
453
1
0
0
1657576680301
number
default
572
301
1
0
1
6.4
1657633533622
gate
default
348
104
1
1
1657575534204
4
0
1657633541386
gate
default
307
103
1
1
1657575534204
3
0
1657633582868
one
default
347
52
1
3
1657633533622
1
1657633541386
1
1657633541386
0
0
1657633590194
zero
default
390
52
1
3
1657633533622
1
1657633541386
1
1657633533622
0
0
1657633754507
bang
default
190
53
1
1
1657633582868
0
0
1657633763714
bang
default
245
50
1
1
1657633590194
0
0
1
default
22
1657575534204
1657575624792
1657575630687
1657575600545
1657575666308
1657575571677
1657576445966
1657575617599
1657576522166
1657576573997
1657576437848
1657576509898
1657576608712
1657576612524
1657575639277
1657575655387
1657633533622
1657633590194
1657633582868
1657633754507
1657633541386
1657633763714
