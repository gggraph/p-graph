80
bang
9
# [bang] can trigger output on mouse down 
#        & has visual effect on receiving data
#                      |
#                    [bang]
#                      |
--decl
inp(1); outp(1)
--code
out0(0)
clock
12
# [clock] output its message after one second
#         
#                     *   
#                     |     
#                [ clock  ]
#                     |
--decl
inp(1)
outp(1)
--code
await wait(1000)
out0(0)
color
13
# [color] set color for [pix] [fill] 
#            and other graphics box
#
#                  *  r  g b
#                  |  |  |  |
#                [   color  ]
#                  |                  
--decl
inp(4)
outp(1)
--code
SetColor(mem(1),mem(2),mem(3))
out0(0)
fill
11
# [fill] clear display with current color 
#        
#                      |
#                    [fill]
#                      |                      
--decl
inp(1)
outp(1)
--code
ClearScreen()
out0(0)
inc
13
# [inc] increment its memory every time 
#        it is triggered
#                          set
#                      |  |
#                    [inc  ]
#                      |
--decl
inp(2)
outp(1)
memset(2)
--code
mem(1)+=1;
out0(1);
log
10
# [log] print its memory to browser
#         console
#
#                      |
#                    [log]
#                      
--decl
inp(1);outp(0);
--code
console.log(mem(0))
pix
11
# [pix] print a pixel on screen at position x and y
#       
#                *  x   y
#                |  |   |
#               [pix      ]
#                |
#
--decl
inp(3); outp(1)
--code
SetPixel(mem(1),mem(2))
pen
14
# [pen] set resolution of screen pixel 
#          printing command
#
#                  *  res 
#                  |   |   
#               [pen    ]
#                |
#
--decl
inp(2)
outp(1)
--code
SetPenWidth(mem(1))
out0(0)
pipe
13
# [pipe] output its message after a certain time
#         time set in input#2 is in ms
#                 *   time
#                 |     |
#                [ pipe  ]
#                 |
--decl
inp(2)
outp(1)
mem(1)=1000
--code
await wait(mem(1))
out0(0)
slider
6
# [slider] outputs integer with
#             special interaction
--decl
inp(1); outp(1);
--code
out0(0)
knob
7
# [knob] outputs integer with
#             special interaction
--decl
inp(1)
outp(1)
--code
out0(0)
number
7
# [number] outputs integer with
#             a special display
--decl
inp(1)
outp(1)
--code
out0(0)
floor
11
# [floor] round a value to its lowest 
#
#                      |
#                    [floor]
#                      |
--decl
inp(1)
outp(1)
--code
mem(0) = Math.floor(mem(0))
out0(0)
/
12
# [ / ] divide a number with
#       divider pass in second entry
#
#	          q   d
#                      |  |
#                    [ /   ]
#                      |
--decl
inp(2); outp(1);
--code
mem(0) /= mem(1)
out0(0)
switch
11
# [switch] pass or block routine
#              on click, user can set to 0 or I
#	          
#                      |   
#                    [switch]
#                      |
--decl
inp(2)
outp(1)
--code
if (mem(1)==0){out0(0);}
rand
18
# [rand]  out a random number 
#            range can be set by passing
#            minimum value at entry 1
#            maximum value at entry 2
#
#                  *  m   mx
#                  |   |   |
#                [rand     ]
#                  |
--decl
inp(3)
outp(1)
mem(1)=0
mem(2)=200
--code
mem(0) = Math.random() * (mem(2)-mem(1))+ mem(1)
mem(0) = Math.floor(mem(0))
out0(0)
metro
0
+
5
--decl
inp(2); outp(1);
--code
mem(0) += mem(1)
out0(0)
-
5
--decl
inp(2); outp(1);
--code
mem(0) -= mem(1)
out0(0)
<
4
--decl
inp(2); outp(2);
--code
if ( mem(0) < mem(1) ){ out0(0);} else{ out1(0)}
>
4
--decl
inp(2); outp(2);
--code
if ( mem(0) > mem(1) ){ out0(0);}else{ out1(0)}
*
5
--decl
inp(2); outp(1);
--code
mem(0) *= mem(1)
out0(0)
>=
4
--decl
inp(2); outp(2);
--code
if ( mem(0) >= mem(1) ){ out0(0);}else{ out1(0)}
<=
4
--decl
inp(2); outp(2);
--code
if ( mem(0) <= mem(1) ){ out0(0);}else{ out1(0)}
==
4
--decl
inp(2); outp(2);
--code
if ( mem(0) == mem(1) ){ out0(0);}else{ out1(0)}
zero
10
# [zero] output 0
#        
#                      |
#                    [zero]
#                      |
--decl
inp(1); outp(1)
--code
mem(0) =0
out0(0)
one
10
# [one] output 1
#        
#                      |
#                    [one]
#                      |
--decl
inp(1); outp(1)
--code
mem(0) =1
out0(0)
hashmux32
75
# [hashmux32] output 32 values between 0 and 255
#                     from a hash string
#
#             |
#         [hashmux32                               ]
#             ||||||||||||||||||||||||||||||||
--decl
inp(1)
outp(32)
memset(32)
--code
mem(0) = HashMux32(mem(0))
mem(1) = mem(0)[1]
mem(2) = mem(0)[2]
mem(3) = mem(0)[3]
mem(4) = mem(0)[4]
mem(5) = mem(0)[5]
mem(6) = mem(0)[6]
mem(7) = mem(0)[7]
mem(8) = mem(0)[8]
mem(9) = mem(0)[9]
mem(10) = mem(0)[10]
mem(11) = mem(0)[11]
mem(12) = mem(0)[12]
mem(13) = mem(0)[13]
mem(14) = mem(0)[14]
mem(15) = mem(0)[15]
mem(16) = mem(0)[16]
mem(17) = mem(0)[17]
mem(18) = mem(0)[18]
mem(19) = mem(0)[19]
mem(20) = mem(0)[20]
mem(21) = mem(0)[21]
mem(22) = mem(0)[22]
mem(23) = mem(0)[23]
mem(24) = mem(0)[25]
mem(26) = mem(0)[26]
mem(27) = mem(0)[27]
mem(28) = mem(0)[28]
mem(29) = mem(0)[29]
mem(30) = mem(0)[30]
mem(31) = mem(0)[31]
mem(0) = mem(0)[0]
out0(0)
out1(1)
out2(2)
out3(3)
out4(4)
out5(5)
out6(6)
out7(7)
out8(8)
out9(9)
out10(10)
out11(11)
out12(12)
out13(13)
out14(14)
out15(15)
out16(16)
out17(17)
out18(18)
out19(19)
out20(20)
out21(21)
out22(22)
out23(23)
out24(24)
out25(25)
out26(26)
out27(27)
out28(28)
out29(29)
out30(30)
out31(31)
int
0
str
0
loadblock
13
# [loadblock] load a block at index in its internal memory 
#             then outputs it
#
#               index
#            |    |
#         [loadblock] 
#              |
--decl
inp(2)
outp(1)
--code
mem(0) = await Network.LoadBlockAtIndex(mem(1))
out0(0)
chainheight
12
# [chainheight] outputs blockchain length when triggered
#               as number
#
#               |
#         [chainheight]
#               |
--decl
inp(1)
outp(1)
--code
mem(0) = await Network.GetBlockchainLength()
out0(0)
blockhash
13
# [blockhash] output hash of a block as a string
#
#            block 
#              |    
#         [blockhash] 
#              |
--decl
inp(1)
outp(1)
--code
if ( mem(0).hash != 'undefined'){Network.SetInternalBlock(mem(0));}
mem(0) = Network.GetBlockHash();
out0(0)
blocktime
14
# [blocktime] output timestamp of a block as UNIX 
#	      timestamp
#
#            block 
#              |    
#         [blocktime] 
#              |
--decl
inp(1)
outp(1)
--code
if ( mem(0).timestamp != 'undefined'){Network.SetInternalBlock(mem(0));}
mem(0) = Network.GetTimeStamp();
out0(0)
blockheight
14
# [blockheight] output height of a block
#	        
#
#            block 
#              |    
#         [blockheight] 
#              |
--decl
inp(1)
outp(1)
--code
if ( mem(0).timestamp != 'undefined'){Network.SetInternalBlock(mem(0));}
mem(0) = Network.GetBlockIndex();
out0(0)
hashlerp
12
# [hashlerp] lerp hash value between 0 and 1
#                
#
#               |
#         [hashlerp  ]
#               |
--decl
inp(1)
outp(1)
--code
mem(0) = LerpHash(mem(0))
out0(0)
sel
0
gate
11
# [gate]  pass or block routine 
#            if second input above 0
#	          
#                      |    |
#                    [gate ]
#                      |   
--decl
inp(2)
outp(1)
--code
if (mem(1)==0){out0(0);}
onload
8
# [onload] bang when project open
#                      
#                    [onload]
#                      |
--decl
inp(0); outp(1)
--code
out0(0)
dec
13
# [dec] decrement its memory every time 
#        it is triggered
#                          set
#                      |  |
#                    [dec  ]
#                      |
--decl
inp(2)
outp(1)
memset(2)
--code
mem(1)-=1;
out0(1);
sin~
14
# [sin~]  outputs a sine wave
#        
#                      *    freq  length
#                      |    |       |
#                    [sin~         ]
#                      |
--decl
inp(3)
outp(1)
mem(1)=800
mem(2)=0.1
--code
mem(0) = new Wave("sine",mem(1),mem(2))
out0(0)
sqr~
14
# [sqr~]  outputs a square wave
#        
#                      *    freq  length
#                      |    |       |
#                    [sqr~         ]
#                      |
--decl
inp(3)
outp(1)
mem(1)=800
mem(2)=0.1
--code
mem(0) = new Wave("square",mem(1),mem(2))
out0(0)
tri~
14
# [tri~]  outputs a triangle wave
#        
#                      *    freq  length
#                      |    |       |
#                    [tri~         ]
#                      |
--decl
inp(3)
outp(1)
mem(1)=800
mem(2)=0.1
--code
mem(0) = new Wave("triangle",mem(1),mem(2))
out0(0)
saw~
14
# [saw~]  outputs a sawtooth wave
#       
#                      *    freq  length
#                      |    |       |
#                    [saw~         ]
#                      |
--decl
inp(3)
outp(1)
mem(1)=800
mem(2)=0.1
--code
mem(0) = new Wave("sawtooth",mem(1),mem(2))
out0(0)
env~~
12
# [env~~]  set enveloppe of wave
#       
#                      w    a  s  r
#                      |    |   |  |
#                    [env~~         ]
#                      |
--decl
inp(4)
outp(1)
--code
mem(0).SetEnvelope(mem(1),mem(2),mem(3))
out0(0)
vib~~
12
# [vib~~]  set sine lfo on wave
#       
#                      w    f  w  
#                      |    |   | 
#                    [vib~~        ]
#                      |
--decl
inp(3)
outp(1)
--code
mem(0).SetVibrato(mem(1),mem(2))
out0(0)
del~
11
# [del~]  pass delay parameters on audio
#       
#                      
#                      |    |    | 
#                    [del~        ]
#                      
--decl
inp(4)
outp(0)
--code
SetDelay(mem(1),mem(2),mem(3))
~~
11
# [~~] set main volume
#       
#                      
#                      |   
#                    [~~]
#      
--decl
inp(1)
outp(0)
--code
SetVolume(mem(0))
osc~~
11
# [osc~~] play wave
#        
#                      *    
#                      |   
#                    [osc~~]
#                      |
--decl
inp(1)
outp(0)
--code
PlayWave(mem(0))
lerp
11
# [lerp] lerp a value between min and max 
#                *      mn mx  r
#                |      |    |     |
#              [lerp                ]
#                |
--decl
inp(4)
outp(1)
--code
mem(0) = Math.abs(mem(1)-mem(2)) * mem(3)
out0(0)
tab
15
# a tab just an array that can be displayed and set by interacting
#                              *  o  st
#                              |  |  |
#                              [tab  ] 
#                              |
#
--decl
inp(3)
outp(1)
memset(4)
mem(3)=new Array(50).fill(0);
--code
mem(3)[mem(2)] = mem(0)
mem(0) = mem(3)[mem(1)]
out0(0)
graph
17
# 2-dim tab that can be displayed and set by interacting
#                              *  xo   yo xi   yi
#                              |  |    |    |    | 
#                              [graph             ] 
#                              |  
#
--decl
inp(5)
outp(1)
memset(6)
mem(5)=new Array()
var i
for (i=0; i<50;i++){ mem(5).push(new Array(50).fill(0)); }
--code
mem(5)[mem(3)][mem(4)] = mem(0)
mem(0) = mem(5)[mem(1)][mem(2)]
out0(0)
square
12
# [square] stroke a square
#       
#                *  x   y  s
#                |  |   |   |
#               [square       ]
#                |
#
--decl
inp(4); outp(1)
--code
StrokeSquare(mem(1),mem(2), mem(3))
out0(0)
squarefill
12
# [squarefill] fill a square
#       
#                *  x   y  s
#                |  |   |   |
#               [squarefill      ]
#                |
#
--decl
inp(4); outp(1)
--code
FillSquare(mem(1),mem(2), mem(3))
out0(0)
rect
12
# [rect] stroke a rect
#       
#                *  x   y  w  h
#                |  |   |   |   |
#               [rect            ]
#                |
#
--decl
inp(5); outp(1)
--code
StrokeRect(mem(1),mem(2), mem(3), mem(4))
out0(0)
rectfill
12
# [rectfill] fill a rect
#       
#                *  x   y  w  h
#                |  |   |   |   |
#               [rectfill         ]
#                |
#
--decl
inp(5); outp(1)
--code
FillRect(mem(1),mem(2), mem(3), mem(4))
out0(0)
circle
12
# [circle] stroke a circle
#       
#                *  x   y  s
#                |  |   |   |
#               [circle       ]
#                |
#
--decl
inp(4); outp(1)
--code
StrokeCircle(mem(1),mem(2), mem(3))
out0(0)
circlefill
12
# [circlefill] fill a circle
#       
#                *  x   y  s
#                |  |   |   |
#               [circlefill       ]
#                |
#
--decl
inp(4); outp(1)
--code
FillCircle(mem(1),mem(2), mem(3))
out0(0)
line
12
# [line] draw a line
#       
#                *  x   y  x1  y1
#                |  |   |   |   |
#               [line             ]
#                |
#
--decl
inp(5); outp(1)
--code
DrawLine(mem(1),mem(2), mem(3), mem(4))
out0(0)
arc
12
# [arc] stroke a arc
#       
#                *  x   y  r   a
#                |  |   |   |   |
#               [arc            ]
#                |
#
--decl
inp(5); outp(1)
--code
StrokeArc(mem(1),mem(2), mem(3), mem(4))
out0(0)
arcfill
12
# [arcfill] fill a arc
#       
#                *  x   y  r   a
#                |  |   |   |   |
#               [arcfill             ]
#                |
#
--decl
inp(5); outp(1)
--code
FillArc(mem(1),mem(2), mem(3), mem(4))
out0(0)
$
9
#     [$] Bang memory 1
#                      | |
#                    [$  ]
#                      |
--decl
inp(2)
outp(1)
--code
out0(1)
neg
6
--decl
inp(1)
outp(1)
--code
mem(0) = -mem(0)
out0(0)
abs
6
--decl
inp(1)
outp(1)
--code
mem(0) = Math.abs(mem(0))
out0(0)
pi
7
# Output pi
--decl
inp(1)
outp(1)
--code
mem(0) = Math.PI
out0(0)
blocknonce
14
# [blocknonce] output nonce of a block
#	        
#
#            block 
#              |    
#         [blocknonce] 
#              |
--decl
inp(1)
outp(1)
--code
if ( mem(0).timestamp != 'undefined'){Network.SetInternalBlock(mem(0));}
mem(0) = Network.GetBlockNonce();
out0(0)
blockprehash
14
# [blockprehash] output previous hash of block
#	        
#
#            block 
#              |    
#         [blockprehash] 
#              |
--decl
inp(1)
outp(1)
--code
if ( mem(0).timestamp != 'undefined'){Network.SetInternalBlock(mem(0));}
mem(0) = Network.GetBlockPreviousHash();
out0(0)
blocktx
15
# [blocktx] output address of a block transactions 
#               at index
#	        
#
#            block   index
#              |       |
#         [blocktx] 
#              |
--decl
inp(2)
outp(1)
--code
if ( mem(0).timestamp != 'undefined'){Network.SetInternalBlock(mem(0));}
mem(0) = Network.GetBlockTransactionAddress(mem(1));
out0(0)
blockgas
14
# [blockgas] output gas used inside block
#	        
#
#            block 
#              |    
#         [blockgas] 
#              |
--decl
inp(1)
outp(1)
--code
if ( mem(0).timestamp != 'undefined'){Network.SetInternalBlock(mem(0));}
mem(0) = Network.GetBlockGasUsed();
out0(0)
blocksize
14
# [blocksize] output byte length of block
#	        
#
#            block 
#              |    
#         [blocksize] 
#              |
--decl
inp(1)
outp(1)
--code
if ( mem(0).timestamp != 'undefined'){Network.SetInternalBlock(mem(0));}
mem(0) = Network.GetBlockBytesSize();
out0(0)
tx
13
# [tx] output transaction from address
#	        
#
#           addr
#           |    
#         [tx ] 
#           |
--decl
inp(1)
outp(1)
--code
mem(0) = await Network.LoadTransaction(mem(0));
out0(0)
txhash
13
# [txhash] output hash of transaction
#	        
#
#          tx
#          |    
#         [txhash] 
#          |
--decl
inp(1)
outp(1)
--code
mem(0) = await Network.GetTransactionHash();
out0(0)
txgas
13
# [txgas] output gas used for this transaction
#	        
#
#          tx
#          |    
#         [txgas] 
#          |
--decl
inp(1)
outp(1)
--code
mem(0) = await Network.GetTransactionGasUsed();
out0(0)
txprice
13
# [txprice] output gas price when transaction validated
#	        
#
#          tx
#          |    
#         [txgas] 
#          |
--decl
inp(1)
outp(1)
--code
mem(0) = await Network.GetTransactionGasPrice();
out0(0)
txcreator
13
# [txcreator] output address of transaction creator
#	        
#
#          tx
#          |    
#         [txcreator] 
#          |
--decl
inp(1)
outp(1)
--code
mem(0) = await Network.GetTransactionAccountAddr();
out0(0)
loadcontract
0
storagesize
13
# [storagesize] output number of variables inside
#	         smartcontract
#
#           *
#           |    
#         [storagesize] 
#           |
--decl
inp(1)
outp(1)
--code
mem(0) = Network.GetStorageLength();
out0(0)
contractaddr
13
# [contractaddr] output address of a contract
#	        
#
#           *
#           |    
#         [contractaddr] 
#           |
--decl
inp(1)
outp(1)
--code
mem(0) = Network.GetContractAddress();
out0(0)
storage
18
# [storage] output value of a smartcontract at address and 
#               name of the variable 
#	        
#
#            index 
#            |    
#         [storage  ] 
#            |     |
--decl
inp(1)
outp(2)
memset(3)
--code
mem(3) = mem(0)
mem(0) = await Network.GetStorageKeyAtIndex(mem(3));
mem(1) = await Network.GetStorageValueAtIndex(mem(3));
out1(1)
out0(0)
gasprice
13
# [gasprice] output current gas price of ethereum 
#	       network
#
#           * 
#           |    
#         [gasprice] 
#           |
--decl
inp(1)
outp(1)
--code
mem(0) = await Network.GetAverageGasPrice();
out0(0)
1
default
24
1657715934787
knob
default
278
63
1
1
1657715942933
0
1
12.777777777777777
1657715942933
floor
default
407
168
1
1
1657715946865
0
0
1657715946865
* 10
default
342
214
1
1
1657715953731
0
0
1657715953731
+ 10
default
404
217
1
1
1657715964912
0
0
1657715964912
number
default
378
278
1
1
1657715973372
1
1
130
1657715973372
pipe
default
179
94
1
1
1657715993205
0
0
1657715993205
bang
default
119
100
1
2
1657715973372
0
1657716008626
0
0
1657716008626
switch
default
74
149
1
1
1657716014386
0
2
0
0
1657716014386
inc
default
104
222
1
1
1657716021154
0
0
1657716021154
number
default
194
285
1
2
1657716025351
0
1657716099939
0
1
34
1657716025351
> 60
default
190
338
2
1
1657716041197
0
1
1657716044955
0
0
1657716041197
bang
default
142
396
1
1
1657716065860
0
0
1657716044955
bang
default
246
400
1
1
1657716114287
0
0
1657716065860
zero
default
62
384
1
5
1657716014386
1
1657716074874
0
1657716074874
1
1657716074874
2
1657716074874
3
0
1657716074874
color
default
57
464
1
1
1657716088289
0
0
1657716088289
fill
default
62
531
1
0
0
1657716099939
bang
default
139
329
1
0
0
1657716114287
* 4
default
293
440
1
2
1657716130308
3
1657716130308
0
0
1657716130308
color
default
220
496
1
1
1657716161137
0
0
1657716161137
fill
default
239
546
1
0
0
1657716172622
knob
default
475
354
1
1
1657716130308
1
1
21.666666666666668
1657716177068
knob
default
557
353
1
1
1657716130308
2
1
34.44444444444444
1657716218657
onload
default
508
74
1
3
1657715934787
0
1657716172622
0
1657716177068
0
0
1657716234430
onload
default
548
113
1
1
1657715993205
0
0
1
default
24
1657715953731
1657715964912
1657715934787
1657715973372
1657715993205
1657716008626
1657716014386
1657716041197
1657716044955
1657716074874
1657716065860
1657716088289
1657716021154
1657716025351
1657716114287
1657716130308
1657716161137
1657716172622
1657716099939
1657715942933
1657715946865
1657716177068
1657716218657
1657716234430
