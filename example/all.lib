161
bang
9
# [bang] pass value when clicked 
#                      |
#                    [bang]
#                      |
--decl
inp(1); outp(1)
--code
out0(0)
#df  Pass a value when user click on it
clock
14
# [clock] output its message after one second
#         
#                     *   
#                     |     
#                [ clock  ]
#                     |
--decl
inp(1)
outp(1)
--code
await wait(1000)
out0(0)
#
#df Pass a value one second later
color
19
# [color] Ouput color as HTML5 definition
#
#                  *  r  g b
#                  |  |  |  |
#                [   color  ]
#                  |                  
--decl
inp(4)
outp(1)
--code
mem(0) = GetColor(mem(1),mem(2),mem(3))
out0(0)
#
#df Output color object 
#i0 Call
#i1 Set red value between [0-255]
#i2 Set green value between [0-255]
#i3 Set blue value between [0-255]
#o0 Out
fill
17
# [fill] clear display with given color 
#        
#                      |   |
#                    [fill   ]
#                      |                      
--decl
inp(2)
outp(1)
mem(1) = GetColor(0,0,0)
--code
OutputCanvas.Fill(mem(1))
out0(0)
#
#df Fill the screen with a color
#i0 Call
#i1 Set color. Default is black.
#o0 Out
inc
17
# [inc] increment its memory every time 
#        it is triggered
#                          set
#                      |  |
#                    [inc  ]
#                      |
--decl
inp(2)
outp(1)
memset(2)
--code
mem(1)+=1;
out0(1);
#df Increment number each call 
#i0 Call
#i1 Store number
#o0 Out
print
12
# [print] print its memory to browser
#         console
#
#                      |
#                    [log]
#                      
--decl
inp(1);outp(0);
--code
console.log(mem(0))
#df  Output value to browser console
#i0  Call
pix
18
# [pix] print a pixel on screen at position x and y
#       
#                *  x   y  c
#                |  |   |   |
#               [pix         ]
#                |
#
--decl
inp(4); outp(1)
mem(3) = GetColor(255,255,255)
--code
OutputCanvas.FillSquare(mem(1),mem(2), 1, mem(3))
#df Print a pixel on screen
#i0 Call
#i1 Set x position
#i2 Set y position
#i3 Set pixel color
#o0 Out
%
9
--decl
inp(2); outp(1);
--code
mem(0) = mem(0) % mem(1)
out0(0)
#df Ouput modulo of two numbers
#i0 Set first number and call 
#i1 Set second number 
#o0 Out
pipe
17
# [pipe] output its message after a certain time
#         time set in input#2 is in ms
#                 *   time
#                 |     |
#                [ pipe  ]
#                 |
--decl
inp(2)
outp(1)
mem(1)=1000
--code
await wait(mem(1))
out0(0)
#df Pass value after specific amount of time
#i0 Call
#i1 Set delay as milliseconds
#o0 Out
slider
9
# [slider] outputs integer with
#             special interaction
--decl
inp(1); outp(1); memset(3);
mem(2) = 200
--code
out0(0)
#i0 Call
#o0 Out
knob
11
# [knob] outputs integer with
#             special interaction
--decl
inp(1)
outp(1)
memset(3)
mem(2)=200
--code
out0(0)
#i0 Call
#o0 Out
number
9
# [number] outputs integer with
#             a special display
--decl
inp(1)
outp(1)
--code
out0(0)
#i0 Call
#o0 Out
floor
14
# [floor] round a value to its lowest 
#
#                      |
#                    [floor]
#                      |
--decl
inp(1)
outp(1)
--code
mem(0) = Math.floor(mem(0))
out0(0)
#df Round value to its lowest integer
#i0 Call
#o0 Out
/
16
# [ / ] divide a number with
#       divider pass in second entry
#
#	          q   d
#                      |  |
#                    [ /   ]
#                      |
--decl
inp(2); outp(1);
--code
mem(0) /= mem(1)
out0(0)
#df Divide value
#i0 Set quotient and Call 
#i1 Set divider
#o0 Out
switch
13
# [switch] pass or block routine
#              on click, user can set to 0 or I
#	          
#                      |   
#                    [switch]
#                      |
--decl
inp(2)
outp(1)
--code
if (mem(1)==0){out0(0);}
#i0 Call
#o0 Out
rand
23
# [rand]  out a random number 
#            range can be set by passing
#            minimum value at entry 1
#            maximum value at entry 2
#
#                  *  m   mx
#                  |   |   |
#                [rand     ]
#                  |
--decl
inp(3)
outp(1)
mem(1)=0
mem(2)=200
--code
mem(0) = Math.random() * (mem(2)-mem(1))+ mem(1)
mem(0) = Math.floor(mem(0))
out0(0)
#df Output a random number
#i0 Call
#i1 Set minimum
#i2 Set maximum
#o0 Out
**
9
--decl
inp(2); outp(1);
--code
mem(0) = mem(0) ** mem(1)
out0(0)
#df Output power of two numbers
#i0 Set first number and call 
#i1 Set second number 
#o0 Out
+
9
--decl
inp(2); outp(1);
--code
mem(0) += mem(1)
out0(0)
#df Add two numbers
#i0 Set first number and call 
#i1 Set second number 
#o0 Out
-
9
--decl
inp(2); outp(1);
--code
mem(0) -= mem(1)
out0(0)
#df Substract two numbers
#i0 Set first number and call 
#i1 Set second number 
#o0 Out
<
8
--decl
inp(2); outp(2);
--code
if ( mem(0) < mem(1) ){ out0(0);} else{ out1(0)}
#df Out left if number below value, else out right
#i0 Call 
#i1 Set value to compare
#o0 Out
>
8
--decl
inp(2); outp(2);
--code
if ( mem(0) > mem(1) ){ out0(0);}else{ out1(0)}
#df Out left if number above value, else out right
#i0 Call 
#i1 Set value to compare
#o0 Out
*
9
--decl
inp(2); outp(1);
--code
mem(0) *= mem(1)
out0(0)
#df Multiply two numbers
#i0 Set first number and call 
#i1 Set second number 
#o0 Out
>=
8
--decl
inp(2); outp(2);
--code
if ( mem(0) >= mem(1) ){ out0(0);}else{ out1(0)}
#df Out left if number above or equals value, else out right
#i0 Call 
#i1 Set value to compare
#o0 Out
<=
8
--decl
inp(2); outp(2);
--code
if ( mem(0) <= mem(1) ){ out0(0);}else{ out1(0)}
#df Out left if number below or equals value, else out right
#i0 Call 
#i1 Set value to compare
#o0 Out
==
8
--decl
inp(2); outp(2);
--code
if ( mem(0) == mem(1) ){ out0(0);}else{ out1(0)}
#df Out left if number equals value, else out right
#i0 Call 
#i1 Set value to compare
#o0 Out
zero
13
# [zero] output 0
#        
#                      |
#                    [zero]
#                      |
--decl
inp(1); outp(1)
--code
mem(0) =0
out0(0)
#df Out zero
#i0 Call 
#o0 Out
one
13
# [one] output 1
#        
#                      |
#                    [one]
#                      |
--decl
inp(1); outp(1)
--code
mem(0) =1
out0(0)
#df Out one
#i0 Call 
#o0 Out
sqrt
6
--decl
inp(1); outp(1);
--code
mem(0) = Math.sqrt(mem(0))
out0(0)
#df Output square root of a number
int
7
--decl
inp(1)
outp(1)
--code
mem(0)=parseInt(mem(0))
out0(0)
#df Convert string to integer
str
7
--decl
inp(1)
outp(1)
--code
mem(0)=mem(0).toString()
out0(0)
#df Convert value to string
loadblock
17
# [loadblock] load a block at index in its internal memory 
#             then outputs it
#
#               index
#            |    |
#         [loadblock] 
#              |
--decl
inp(2)
outp(1)
--code
mem(0) = await Network.LoadBlockAtIndex(mem(1))
out0(0)
#df Output a blockchain block object
#i0 Call 
#i1 Set blockchain block index
#o0 Out
chainheight
15
# [chainheight] outputs blockchain length when triggered
#               as number
#
#               |
#         [chainheight]
#               |
--decl
inp(1)
outp(1)
--code
mem(0) = await Network.GetBlockchainLength()
out0(0)
#df Ouput current blockchain height
#i0 Call 
#o0 Out
blockhash
16
# [blockhash] output hash of a block as a string
#
#            block 
#              |    
#         [blockhash] 
#              |
--decl
inp(1)
outp(1)
--code
if ( mem(0).hash != 'undefined'){Network.SetInternalBlock(mem(0));}
mem(0) = Network.GetBlockHash();
out0(0)
#df Output hash of a blockchain block object
#i0 Block
#o0 Out
blocktime
17
# [blocktime] output timestamp of a block as UNIX 
#	      timestamp
#
#            block 
#              |    
#         [blocktime] 
#              |
--decl
inp(1)
outp(1)
--code
if ( mem(0).timestamp != 'undefined'){Network.SetInternalBlock(mem(0));}
mem(0) = Network.GetBlockTimeStamp();
out0(0)
#df Output unix timestamp of a blockchain block object
#i0 Block
#o0 Out
blockheight
17
# [blockheight] output height of a block
#	        
#
#            block 
#              |    
#         [blockheight] 
#              |
--decl
inp(1)
outp(1)
--code
if ( mem(0).timestamp != 'undefined'){Network.SetInternalBlock(mem(0));}
mem(0) = Network.GetBlockIndex();
out0(0)
#df Output height of a blockchain block object
#i0 Block
#o0 Out
hashlerp
15
# [hashlerp] lerp hash value between 0 and 1
#                
#
#               |
#         [hashlerp  ]
#               |
--decl
inp(1)
outp(1)
--code
mem(0) = LerpHash(mem(0))
out0(0)
#df Output a value between [0-1] from a hash
#i0 Hash
#o0 Out
sel
8
#df Output to one of its wire out if value received correspond
--decl
inp(1)
outp(1)
--code
for ( var i = 1 ; i < self.memory.length; i++){
if(self.memory[i] == mem(0)){self.O(i,i)}
}
gate
15
# [gate]  pass or block routine 
#            if second input above 0
#	          
#                      |    |
#                    [gate ]
#                      |   
--decl
inp(2)
outp(1)
--code
if (mem(1)==0){out0(0);}
#df Pass value if number equal zero
#i0 Call 
#i1 Set number
#o0 Out
onload
8
# [onload] bang when project open
#                      
#                    [onload]
#                      |
--decl
inp(0); outp(1)
#df Call when project load
#o0 Out
dec
17
# [dec] decrement its memory every time 
#        it is triggered
#                          set
#                      |  |
#                    [dec  ]
#                      |
--decl
inp(2)
outp(1)
memset(2)
--code
mem(1)-=1;
out0(1);
#df Decrement number each call 
#i0 Call
#i1 Set number
#o0 Out
sin~
27
# [sin~]  outputs a sine wave
#        
#                      x    freq
#                      |    |    
#                    [sin~ ]
#                      |
--decl
inp(2)
outp(1)
self.audioNode = audioContext.createOscillator();
self.audioNode.type = 'sine';
self.audioNode.frequency.setValueAtTime(800, 0);
self.audioNode.start(0);
--code
--ipf1
self.audioNode.frequency.setValueAtTime(mem(1), 0);
--wi0
OnNodeConnect(wblock,self.audioNode);
--dcwi0
OnNodeDisconnect(wblock,self.audioNode);
--wi1
OnNodeConnect(wblock,self.audioNode.frequency);
--dcwi1
OnNodeDisconnect(wblock,self.audioNode.frequency);
#df Output a sine wave
#i0 reserved
#i1 Set frequency
sqr~
27
# [sqr~]  outputs a square wave
#        
#                      x    freq
#                      |    |    
#                    [sin~ ]
#                      |
--decl
inp(2)
outp(1)
self.audioNode = audioContext.createOscillator();
self.audioNode.type = 'square'
self.audioNode.frequency.setValueAtTime(800, 0);
self.audioNode.start(0);
--code
--ipf1
self.audioNode.frequency.setValueAtTime(mem(1), 0);
--wi0
OnNodeConnect(wblock,self.audioNode);
--dcwi0
OnNodeDisconnect(wblock,self.audioNode);
--wi1
OnNodeConnect(wblock,self.audioNode.frequency);
--dcwi1
OnNodeDisconnect(wblock,self.audioNode.frequency);
#df Output a square wave
#i0 reserved
#i1 Set frequency
tri~
27
# [tri~]  outputs a triangle wave
#        
#                      x    freq
#                      |    |    
#                    [sin~ ]
#                      |
--decl
inp(2)
outp(1)
self.audioNode = audioContext.createOscillator();
self.audioNode.type = 'triangle'
self.audioNode.frequency.setValueAtTime(800, 0);
self.audioNode.start(0);
--code
--ipf1
self.audioNode.frequency.setValueAtTime(mem(1), 0);
--wi0
OnNodeConnect(wblock,self.audioNode);
--dcwi0
OnNodeDisconnect(wblock,self.audioNode);
--wi1
OnNodeConnect(wblock,self.audioNode.frequency);
--dcwi1
OnNodeDisconnect(wblock,self.audioNode.frequency);
#df Output a triangle wave
#i0 reserved
#i1 Set frequency
saw~
27
# [saw~]  outputs a sawtooth wave
#        
#                      x    freq
#                      |    |    
#                    [sin~ ]
#                      |
--decl
inp(2)
outp(1)
self.audioNode = audioContext.createOscillator();
self.audioNode.type = 'sawtooth'
self.audioNode.frequency.setValueAtTime(800, 0);
self.audioNode.start(0);
--code
--ipf1
self.audioNode.frequency.setValueAtTime(mem(1), 0);
--wi0
OnNodeConnect(wblock,self.audioNode);
--dcwi0
OnNodeDisconnect(wblock,self.audioNode);
--wi1
OnNodeConnect(wblock,self.audioNode.frequency);
--dcwi1
OnNodeDisconnect(wblock,self.audioNode.frequency);
#df Output a saw wave
#i0 reserved
#i1 Set frequency
tan
6
--decl
inp(1); outp(1);
--code
mem(0) = Math.tan(mem(0))
out0(0)
#df Output tangent of a number
linear
25
# [linear] linear ramping to value 
#       
#                      value    time
#                      |          |
#                    [linear      ]
#                      |
--decl
inp(2)
outp(1)
memset(5)
--code
if (mem(3) == true){mem(4)  = 0;return;}
mem(3) = true;
mem(4)  = 0
while ( mem(4) <= mem(1)) {
var amt = mem(4) / mem(1)
mem(2) = (1-amt )*mem(2)+amt*mem(0)
out0(2)
await wait(10)
mem(4)+=0.001
}
mem(3) = false;
#df Ramp to value
#i0 Set target value
#i1 Set speed
log
6
--decl
inp(1); outp(1);
--code
mem(0) = Math.log(mem(0))
out0(0)
#df Output natural log of a number
~~
16
# [~~] Speaker
#       
#                      
#                      |   
#                    [~~]
#      
--decl
inp(1)
outp(0)
self.audioNode = audioContext.createGain();
self.audioNode.connect(masterVolume);
--wi0
OnNodeConnect(wblock,self.audioNode);
--dcwi0
OnNodeDisconnect(wblock,self.audioNode);
#df Output signal to speaker
~
24
# [~] gain node
#        
#                      *      v
#                      |      |  
#                    [~        ]
#                      |
--decl
inp(2)
outp(1)
self.audioNode =  audioContext.createGain();
--code
self.audioNode.value= mem(0)
--ipf1
self.audioNode.gain.value = mem(1)
--wi0
OnNodeConnect(wblock,self.audioNode);
--dcwi0
OnNodeDisconnect(wblock,self.audioNode);
--wi1
OnNodeConnect(wblock,self.audioNode.gain);
--dcwi1
OnNodeDisconnect(wblock,self.audioNode.gain);
#df Pass audio signal 
#i1 Modulate signal amplitude by value
lerp
15
# [lerp] linear interpolation between 2 values
#                r      a     b  
#                |      |    |    
#              [lerp          ]
#                |
--decl
inp(3)
outp(1)
--code
mem(0) = (1 - mem(0)) * mem(1) + mem(0) * mem(2)
out0(0)
#df Out value between two numbers
#i0 Set ratio [0-1]
#i1 Set first value
#i2 Set second value
tab
18
# a tab just an array that can be displayed and set by interacting
#                              *  o  st
#                              |  |  |
#                              [tab  ] 
#                              |
#
--decl
inp(3)
outp(1)
memset(4)
mem(3)=new Array(50).fill(0);
--code
out0(3)
--ipf2
mem(3)[mem(1)] = mem(2)
#i0 Out value
#i1 Write index
#i2 Store value
graph
20
# 2-dim tab that can be displayed and set by interacting
#                              *   xi   yi   st
#                              |   |    |    | 
#                              [graph        ] 
#                              |  
#
--decl
inp(4)
outp(1)
memset(6)
mem(5)=new Array()
var i
for (i=0; i<50;i++){ mem(5).push(new Array(50).fill(0)); }
--code
out0(5)
--ipf3
mem(5)[mem(1)][mem(2)] = mem(3)
#i1 Write X-index
#i2 Write Y-index
#i3 Store value
square
20
# [square] stroke a square
#       
#                *  x   y  s   c   lw
#                |  |   |   |   |   |
#               [square             ]
#                |
#
--decl
inp(6); outp(1)
mem(4) = GetColor(255,255,255)
mem(5) = 2
--code
OutputCanvas.StrokeSquare(mem(1),mem(2), mem(3), mem(4), mem(5))
out0(0)
#df Stroke a square
#i1 Set x position
#i2 Set y position
#i3 Set dimension
#i4 Set line color
#i5 Set line width
squarefill
18
# [squarefill] fill a square
#       
#                *  x   y  s   c
#                |  |   |   |   |
#               [squarefill      ]
#                |
#
--decl
inp(5); outp(1)
mem(4) = GetColor(255,255,255)
--code
OutputCanvas.FillSquare(mem(1),mem(2), mem(3), mem(4))
out0(0)
#df Fill a square
#i1 Set x position
#i2 Set y position
#i3 Set dimension
#i4 Set square color
rect
21
# [rect] stroke a rect
#       
#                *  x   y  w  h  c   lw
#                |  |   |   |   |   |  |
#               [rect                    ]
#                |
#
--decl
inp(7); outp(1)
mem(5) = GetColor(255,255,255)
mem(6) = 3
--code
OutputCanvas.StrokeRect(mem(1),mem(2), mem(3), mem(4),mem(5), mem(6))
out0(0)
#df Stroke a rectangle
#i1 Set x position
#i2 Set y position
#i3 Set rectangle width
#i4 Set rectangle height
#i5 Set line color
#i6 Set line width
rectfill
19
# [rectfill] fill a rect
#       
#                *  x   y  w  h  c
#                |  |   |   |   |  |
#               [rectfill           ]
#                |
#
--decl
inp(6); outp(1)
mem(5) = GetColor(255,255,255)
--code
OutputCanvas.FillRect(mem(1),mem(2), mem(3), mem(4), mem(5))
out0(0)
#df Fill a rectangle
#i1 Set x position
#i2 Set y position
#i3 Set rectangle width
#i4 Set rectangle height
#i5 Set rectangle color
circle
20
# [circle] stroke a circle
#       
#                *  x   y  s   c  lw
#                |  |   |   |   |  |
#               [circle             ]
#                |
#
--decl
inp(6); outp(1)
mem(4) = GetColor(255,255,255)
mem(5) = 3
--code
OutputCanvas.StrokeCircle(mem(1),mem(2), mem(3), mem(4) ,mem(5))
out0(0)
#df Stroke a circle
#i1 Set x position
#i2 Set y position
#i3 Set radius
#i4 Set line color
#i5 Set line width
circlefill
18
# [circlefill] fill a circle
#       
#                *  x   y  s   c
#                |  |   |   |   |
#               [circlefill       ]
#                |
#
--decl
inp(5); outp(1)
mem(4) = GetColor(255,255,255)
--code
OutputCanvas.FillCircle(mem(1),mem(2), mem(3), mem(4))
out0(0)
#df Fill a circle
#i1 Set x position
#i2 Set y position
#i3 Set radius
#i4 Set circle color
line
21
# [line] draw a line
#       
#                *  x   y  x1  y1  c   lw
#                |  |   |   |   |    |   |
#               [line                      ]
#                |
#
--decl
inp(7); outp(1)
mem(5) = GetColor(255,255,255)
mem(6) = 3
--code
OutputCanvas.DrawLine(mem(1),mem(2), mem(3), mem(4),mem(5),mem(6))
out0(0)
#df Draw a line
#i1 Set x starting position
#i2 Set y starting position
#i3 Set x ending position
#i4 Set y ending position
#i5 Set line color
#i6 Set line width
arc
24
# [arc] stroke an arc
#       
#                *  x   y  r   st  en c   lw
#                |  |   |   |   |   |   |   |
#               [arc                           ]
#                |
#
--decl
inp(8); outp(1)
mem(6) = GetColor(255,255,255)
mem(7) = 3
--code
var astart = ((2*Math.PI) * (mem(4)/100)) - (Math.PI/2)
var aend = ((2*Math.PI) * (mem(5)/100)) - (Math.PI/2)
OutputCanvas.StrokeArc(mem(1),mem(2), mem(3), astart, aend, mem(6), mem(7))
out0(0)
#df Stroke an arc
#i1 Set x position
#i2 Set y position
#i3 Set radius
#i4 Set angle start in %  [from north]
#i5 Set angle end  in %   [from north]
#i6 Set arc color
#i7 Set line width
arcfill
22
# [arcfill] fill a arc
#       
#                *  x   y  r   st  en  c
#                |  |   |   |   |   |    |
#               [arcfill                    ]
#                |
#
--decl
inp(7); outp(1)
mem(6) = GetColor(255,255,255)
--code
var astart = ((2*Math.PI) * (mem(4)/100)) - (Math.PI/2)
var aend = ((2*Math.PI) * (mem(5)/100)) - (Math.PI/2)
OutputCanvas.FillArc(mem(1),mem(2), mem(3), astart, aend, mem(6))
out0(0)
#df Fill a arc
#i1 Set x position
#i2 Set y position
#i3 Set radius
#i4 Set angle start in %  [from north]
#i5 Set angle end  in %   [from north]
#i6 Set arc color
$
11
#     [$] Bang memory 1
#                      | |
#                    [$  ]
#                      |
--decl
inp(2)
outp(1)
--code
out0(1)
#df Output a stored value
#i1 Set value
neg
7
--decl
inp(1)
outp(1)
--code
mem(0) = -mem(0)
out0(0)
#df Negate a value
abs
7
--decl
inp(1)
outp(1)
--code
mem(0) = Math.abs(mem(0))
out0(0)
#df Output absolute value
pi
8
# Output pi
--decl
inp(1)
outp(1)
--code
mem(0) = Math.PI
out0(0)
#df Output pi
blocknonce
16
# [blocknonce] output nonce of a block
#	        
#
#            block 
#              |    
#         [blocknonce] 
#              |
--decl
inp(1)
outp(1)
--code
if ( mem(0).timestamp != 'undefined'){Network.SetInternalBlock(mem(0));}
mem(0) = Network.GetBlockNonce();
out0(0)
#df Output nonce of a blockchain block
#i0 Block 
blockprehash
16
# [blockprehash] output previous hash of block
#	        
#
#            block 
#              |    
#         [blockprehash] 
#              |
--decl
inp(1)
outp(1)
--code
if ( mem(0).timestamp != 'undefined'){Network.SetInternalBlock(mem(0));}
mem(0) = Network.GetBlockPreviousHash();
out0(0)
#df Output previous hash of a blockchain block
#i0 Block 
blocktx
18
# [blocktx] output address of a block transactions 
#               at index
#	        
#
#            block   index
#              |       |
#         [blocktx] 
#              |
--decl
inp(2)
outp(1)
--code
if ( mem(0).timestamp != 'undefined'){Network.SetInternalBlock(mem(0));}
mem(0) = Network.GetBlockTransactionAddress(mem(1));
out0(0)
#df Output address of a block transaction
#i0 Block
#i1 Index
blockgas
16
# [blockgas] output gas used inside block
#	        
#
#            block 
#              |    
#         [blockgas] 
#              |
--decl
inp(1)
outp(1)
--code
if ( mem(0).timestamp != 'undefined'){Network.SetInternalBlock(mem(0));}
mem(0) = Network.GetBlockGasUsed();
out0(0)
#df Output gas used inside blockchain block
#i0 Block
blocksize
16
# [blocksize] output byte length of block
#	        
#
#            block 
#              |    
#         [blocksize] 
#              |
--decl
inp(1)
outp(1)
--code
if ( mem(0).timestamp != 'undefined'){Network.SetInternalBlock(mem(0));}
mem(0) = Network.GetBlockBytesSize();
out0(0)
#df Output byte size of a blockchain block
#i0 Block
tx
15
# [tx] output transaction from address
#	        
#
#           addr
#           |    
#         [tx ] 
#           |
--decl
inp(1)
outp(1)
--code
mem(0) = await Network.LoadTransaction(mem(0));
out0(0)
#df Output a transaction from address
#i0 address
txhash
15
# [txhash] output hash of transaction
#	        
#
#          tx
#          |    
#         [txhash] 
#          |
--decl
inp(1)
outp(1)
--code
mem(0) = await Network.GetTransactionHash();
out0(0)
#df Output hash of a transaction
#i0 blockchain transaction
txgas
15
# [txgas] output gas used for this transaction
#	        
#
#          tx
#          |    
#         [txgas] 
#          |
--decl
inp(1)
outp(1)
--code
mem(0) = await Network.GetTransactionGasUsed();
out0(0)
#df Output gas used for a transaction
#i0 blockchain transaction
txprice
15
# [txprice] output gas price when transaction validated
#	        
#
#          tx
#          |    
#         [txgas] 
#          |
--decl
inp(1)
outp(1)
--code
mem(0) = await Network.GetTransactionGasPrice();
out0(0)
#df Output gas price spent for blockchain transaction
#i0 blockchain transaction
txcreator
15
# [txcreator] output address of transaction creator
#	        
#
#          tx
#          |    
#         [txcreator] 
#          |
--decl
inp(1)
outp(1)
--code
mem(0) = await Network.GetTransactionAccountAddr();
out0(0)
#df Output wallet address of a blockchain transaction
#i0 blockchain transaction
loadcontract
0
storagesize
15
# [storagesize] output number of variables inside
#	         smartcontract
#
#           *
#           |    
#         [storagesize] 
#           |
--decl
inp(1)
outp(1)
--code
mem(0) = Network.GetStorageLength();
out0(0)
#df Output number of variables inside a smartcontract
#i0 Smartcontract object
contractaddr
15
# [contractaddr] output address of a contract
#	        
#
#           *
#           |    
#         [contractaddr] 
#           |
--decl
inp(1)
outp(1)
--code
mem(0) = Network.GetContractAddress();
out0(0)
#df Output blockchain contract address
#i0 Smartcontract object
storage
20
# [storage] output value of a smartcontract at address and 
#               name of the variable 
#	        
#
#            index 
#            |    
#         [storage  ] 
#            |     |
--decl
inp(1)
outp(2)
memset(3)
--code
mem(3) = mem(0)
mem(0) = await Network.GetStorageKeyAtIndex(mem(3));
mem(1) = await Network.GetStorageValueAtIndex(mem(3));
out1(1)
out0(0)
#df Output value stored inside smartcontract
#i0 Key index
gasprice
13
# [gasprice] output current gas price of ethereum 
#	       network
#
#           * 
#           |    
#         [gasprice] 
#           |
--decl
inp(1)
outp(1)
--code
mem(0) = await Network.GetAverageGasPrice();
out0(0)
num2mutez
5
--decl
inp(1); outp(1)
--code
mem(0) = StorageValueToMutez(mem(0))
out0(0)
num2tez
5
--decl
inp(1); outp(1)
--code
mem(0) = StorageValueToTez(mem(0))
out0(0)
mutez2tez
5
--decl
inp(1); outp(1)
--code
mem(0) = MutezToTez(mem(0))
out0(0)
tez2mutez
5
--decl
inp(1); outp(1)
--code
mem(0) = TezToMutez(mem(0))
out0(0)
wei2ether
5
--decl
inp(1); outp(1)
--code
mem(0) = WeiToEther(mem(0))
out0(0)
ether2wei
5
--decl
inp(1); outp(1)
--code
mem(0) = EtherToWei(mem(0))
out0(0)
gwei2wei
5
--decl
inp(1); outp(1)
--code
mem(0) = GweiToWei(mem(0))
out0(0)
ether2doll
5
--decl
inp(1); outp(1)
--code
mem(0) = EtherToDollar(mem(0))
out0(0)
ether2eur
5
--decl
inp(1); outp(1)
--code
mem(0) = EtherToEuro(mem(0))
out0(0)
msg
11
# [msg] pass a chain of characters.
#           Change the chain of characters as you do it for renaming blocks.
#                      |
#                    [msg]
#                      |
--decl
inp(1); outp(1);memset(2)
mem(1) = 'hello world'
--code
out0(1)
#df  Pass a chain of characters when user click on it
supermetaparam
9
--decl
inp(5)
--code
# Code editor
 ide.CodeEditor.SetFont('font'+mem(1),mem(2),'');
 ide.CodeEditor.Draw()
# Block
VisualParameters.BlockBorderWidth = mem(3);
VisualParameters.WireWidth = mem(4);
arr
8
--decl
inp(2)
outp(1)
--code
if (mem(0).length > mem(1)){mem(0)=mem(0)[mem(1)];}
out0(0)
#df Ouput element of an array
#i0 Set index
split
9
--decl
inp(2)
outp(1)
mem(1)=' '
--code
mem(0) = mem(0).split(mem(1))
out0(0)
#df Split chain of character
#i1 Set separator
hz2midi
7
--decl
inp(1)
outp(1)
--code
mem(0) = 12 * (Math.log(mem(0)/220)/Math.log(2)) + 57
out0(0)
#df Output midi value from frequency
midi2hz
7
--decl
inp(1)
outp(1)
--code
mem(0)=440*(Math.pow(2,((mem(0)-69)/12)))
out0(0)
#df Output frequency from midi value
len
7
--decl
inp(1)
outp(1)
--code
mem(0)=mem(0).length
out0(0)
#df Output length of an array
max
6
--decl
inp(2); outp(1);
--code
mem(0) = Math.max(mem(0),mem(1))
out0(0)
#df Output highest value from two number
txtfill
18
--decl
inp(7)
outp(1)
mem(3) = GetColor(255,255,255)
mem(5) = 12
mem(6) = ' '
--code
var f = 'font'+mem(4)
OutputCanvas.FillText(mem(0),mem(1),mem(2),mem(3),f, mem(5), mem(6))
out0(0)
#df Draw text on screen
#i0 Text
#i1 Set x position
#i2 Set y position
#i3 Set text color
#i4 Set font index
#i5 Set font size
#i6 Set font style 
txtstroke
18
--decl
inp(7)
outp(1)
mem(3) = GetColor(255,255,255)
mem(5) = 12
mem(6) = ' '
--code
var f = 'font'+mem(4)
OutputCanvas.StrokeText(mem(0),mem(1),mem(2),mem(3),f, mem(5), mem(6))
out0(0)
#df Stroke a text on screen
#i0 Text
#i1 Set x position
#i2 Set y position
#i3 Set text color
#i4 Set font index
#i5 Set font size
#i6 Set font style 
midisq
13
#df Output key tones incrementally from string input
#i0 string
--decl
inp(1)
outp(2)
memset(2)
--code
mem(0) = mem(0).split(' ')
mem(1)++
if (mem(1)>= mem(0).length) { mem(1) = 0}
mem(0) = parseInt(mem(0)[mem(1)])
out0(0)
out1(1)
chord
9
#df Output chord from string input
#i0 string
--decl
inp(1)
outp(1)
memset(2)
--code
mem(1) = mem(0).split(' ')
for ( var i = 0 ; i < mem(1).length; i++) {  mem(0) = mem(1)[i]; out0(0); }
drawgraph
17
--decl
inp(3)
outp(0)
mem(2) = GetColor(255,255,255)
--code
for ( var x = 0 ; x < mem(0).length; x++ ) {
for ( var y = 0; y < mem(0)[x].length; y++){
if ( mem(0)[x][y] != 0 )
{
OutputCanvas.FillSquare(mem(0)[x]*mem(1),mem(0)[y]*mem(1), 30*mem(1), mem(2));
}
}
}
#df Draw mesh from [graph ] object
#i0 2-dim array
#i1 Set dimension
#i2 Set color
midisnd
8
#df Send message to midi device
#i0 Byte array
#i1 Set Device identifier
--decl
inp(2)
mem(1)=1
--code
SendMidiMessage(mem(0), mem(1))
midikey
15
--decl
inp(5)
outp(0)
mem(4)=1
mem(3)=1000
--code
SendKeyOn(mem(1),mem(2),mem(4))
await wait(mem(3))
SendKeyOff(mem(1), mem(4))
#df Send keystroke to midi device
#i0 Call
#i1 Set midi note
#i2 Set velocity
#i3 Set tone length
#i4 Set midi device number
faust~greyhole
79
--decl
inp(8)
outp(1)
#standart Faust WASM implementation
var pluginURL = 'sound/audioworklet/RIPFAUST/greyhole/.';
var plugin = new testworklet(audioContext, pluginURL);
var node = await plugin.load()
self.audioNode = node;
self.audioNode.setParamValue("/Greyhole/Mix/size", 0.5);
--ipf1
self.audioNode.setParamValue("/Greyhole/Mix/damping", mem(1));
--ipf2
self.audioNode.setParamValue("/Greyhole/Mix/delayTime", mem(2));
--ipf3
self.audioNode.setParamValue("/Greyhole/Mix/size", mem(3));
--ipf4
self.audioNode.setParamValue("/Greyhole/Mix/diffusion", mem(4));
--ipf5
self.audioNode.setParamValue("/Greyhole/Mix/feedback", mem(5));
--ipf6
self.audioNode.setParamValue("/Greyhole/Mod/modDepth", mem(6));
--ipf7
self.audioNode.setParamValue("/Greyhole/Mod/modFreq", mem(7));
--wi0
while (self.audioNode == null){ await wait(1000);}
OnNodeConnect(wblock,self.audioNode);
--dcwi0
while (self.audioNode == null){ await wait(1000);}
OnNodeDisconnect(wblock,self.audioNode);
--wi1
while (self.audioNode == null){ await wait(1000);}
OnNodeConnect(wblock,self.audioNode.parameters.get("/Greyhole/Mix/damping"));
--dcwi1
while (self.audioNode == null){ await wait(1000);}
OnNodeDisconnect(wblock,self.audioNode.parameters.get("/Greyhole/Mix/damping"));
--wi2
while (self.audioNode == null){ await wait(1000);}
OnNodeConnect(wblock,self.audioNode.parameters.get("/Greyhole/Mix/delayTime"));
--dcwi2
while (self.audioNode == null){ await wait(1000);}
OnNodeDisconnect(wblock,self.audioNode.parameters.get("/Greyhole/Mix/delayTime"));
--wi3
while (self.audioNode == null){ await wait(1000);}
OnNodeConnect(wblock,self.audioNode.parameters.get("/Greyhole/Mix/size"));
--dcwi3
while (self.audioNode == null){ await wait(1000);}
OnNodeDisconnect(wblock,self.audioNode.parameters.get("/Greyhole/Mix/size"));
--wi4
while (self.audioNode == null){ await wait(1000);}
OnNodeConnect(wblock,self.audioNode.parameters.get("/Greyhole/Mix/diffusion"));
--dcwi4
while (self.audioNode == null){ await wait(1000);}
OnNodeDisconnect(wblock,self.audioNode.parameters.get("/Greyhole/Mix/diffusion"));
--wi5
while (self.audioNode == null){ await wait(1000);}
OnNodeConnect(wblock,self.audioNode.parameters.get("/Greyhole/Mix/feedback"));
--dcwi5
while (self.audioNode == null){ await wait(1000);}
OnNodeDisconnect(wblock,self.audioNode.parameters.get("/Greyhole/Mix/feedback"));
--wi6
while (self.audioNode == null){ await wait(1000);}
OnNodeConnect(wblock,self.audioNode.parameters.get("/Greyhole/Mod/modDepth"));
--dcwi6
while (self.audioNode == null){ await wait(1000);}
OnNodeDisconnect(wblock,self.audioNode.parameters.get("/Greyhole/Mod/modDepth"));
--wi7
while (self.audioNode == null){ await wait(1000);}
OnNodeConnect(wblock,self.audioNode.parameters.get("/Greyhole/Mod/modFreq"));
--dcwi7
while (self.audioNode == null){ await wait(1000);}
OnNodeDisconnect(wblock,self.audioNode.parameters.get("/Greyhole/Mod/modFreq"));
#df GreyHole Faust Implementation
#i1 Set damping [0-1]
#i2 Set delayTime [0-60]
#i3 Set room size [0.5-5]
#i4 Set diffusion   [0-1]
#i5 Set feedback   [0-1]
#i6 Set modulation depth [0-1]
#i6 Set modulation frequency [0-10]
faust~moogvcf
48
--decl
inp(7)
outp(1)
#standart Faust WASM implementation
var pluginURL = 'sound/audioworklet/RIPFAUST/moog_vcf_demo/.';
var plugin = new moog_vcf_demo(audioContext, pluginURL);
var node = await plugin.load()
self.audioNode = node;
--ipf1
self.audioNode.setParamValue("/MOOG_VCF__Voltage_Controlled_Filter_/Corner_Frequency", mem(1));
--ipf2
self.audioNode.setParamValue("/MOOG_VCF__Voltage_Controlled_Filter_/Corner_Resonance", mem(2));
--ipf3
self.audioNode.setParamValue("/MOOG_VCF__Voltage_Controlled_Filter_/VCF_Output_Level", mem(3));
--ipf4
self.audioNode.setParamValue("/MOOG_VCF__Voltage_Controlled_Filter_/0x00/Bypass", mem(4));
--ipf5
self.audioNode.setParamValue("/MOOG_VCF__Voltage_Controlled_Filter_/0x00/Use_Biquads", mem(5));
--ipf6
self.audioNode.setParamValue("/MOOG_VCF__Voltage_Controlled_Filter_/0x00/Normalized", mem(6));
--wi0
while (self.audioNode == null){ await wait(1000);}
OnNodeConnect(wblock,self.audioNode);
--dcwi0
while (self.audioNode == null){ await wait(1000);}
OnNodeDisconnect(wblock,self.audioNode);
--wi1
while (self.audioNode == null){ await wait(1000);}
OnNodeConnect(wblock,self.audioNode.parameters.get("/MOOG_VCF__Voltage_Controlled_Filter_/Corner_Frequency"));
--dcwi1
while (self.audioNode == null){ await wait(1000);}
OnNodeDisconnect(wblock,self.audioNode.parameters.get("/MOOG_VCF__Voltage_Controlled_Filter_/Corner_Frequency"));
--wi2
while (self.audioNode == null){ await wait(1000);}
OnNodeConnect(wblock,self.audioNode.parameters.get("/MOOG_VCF__Voltage_Controlled_Filter_/Corner_Resonance"));
--dcwi2
while (self.audioNode == null){ await wait(1000);}
OnNodeDisconnect(wblock,self.audioNode.parameters.get("/MOOG_VCF__Voltage_Controlled_Filter_/Corner_Resonance"));
--wi3
while (self.audioNode == null){ await wait(1000);}
OnNodeConnect(wblock,self.audioNode.parameters.get("/MOOG_VCF__Voltage_Controlled_Filter_/VCF_Output_Level"));
--dcwi3
while (self.audioNode == null){ await wait(1000);}
OnNodeDisconnect(wblock,self.audioNode.parameters.get("/MOOG_VCF__Voltage_Controlled_Filter_/VCF_Output_Level"));
#df Moog VCF Faust Implementation
#i1 Set Frequency [1-88]
#i2 Set Resonnance [0-1]
#i3 Set Level [-60-20]
faust~flanger
69
--decl
inp(7)
outp(1)
#standart Faust WASM implementation
var pluginURL = 'sound/audioworklet/RIPFAUST/flanger_demo/.';
var plugin = new flanger_demo(audioContext, pluginURL);
var node = await plugin.load()
self.audioNode = node;
--ipf1
self.audioNode.setParamValue("/FLANGER/0x00/Speed", mem(1));
--ipf2
self.audioNode.setParamValue("/FLANGER/0x00/Depth", mem(2));
--ipf3
self.audioNode.setParamValue("/FLANGER/0x00/Feedback", mem(3));
--ipf4
self.audioNode.setParamValue("/FLANGER/Delay_Controls/Flange_Delay", mem(4));
--ipf5
self.audioNode.setParamValue("/FLANGER/Delay_Controls/Delay_Offset", mem(5));
--ipf6
self.audioNode.setParamValue("/FLANGER/0x00/Flanger_Output_Level", mem(6));
--wi0
while (self.audioNode == null){ await wait(1000);}
OnNodeConnect(wblock,self.audioNode);
--dcwi0
while (self.audioNode == null){ await wait(1000);}
OnNodeDisconnect(wblock,self.audioNode);
--wi1
while (self.audioNode == null){ await wait(1000);}
OnNodeConnect(wblock,self.audioNode.parameters.get("/FLANGER/0x00/Speed"));
--dcwi1
while (self.audioNode == null){ await wait(1000);}
OnNodeDisconnect(wblock,self.audioNode.parameters.get("/FLANGER/0x00/Speed"));
--wi2
while (self.audioNode == null){ await wait(1000);}
OnNodeConnect(wblock,self.audioNode.parameters.get("/FLANGER/0x00/Depth"));
--dcwi2
while (self.audioNode == null){ await wait(1000);}
OnNodeDisconnect(wblock,self.audioNode.parameters.get("/FLANGER/0x00/Depth"));
--wi3
while (self.audioNode == null){ await wait(1000);}
OnNodeConnect(wblock,self.audioNode.parameters.get("/FLANGER/0x00/Feedback"));
--dcwi3
while (self.audioNode == null){ await wait(1000);}
OnNodeDisconnect(wblock,self.audioNode.parameters.get("/FLANGER/0x00/Feedback"));
--wi4
while (self.audioNode == null){ await wait(1000);}
OnNodeConnect(wblock,self.audioNode.parameters.get("/FLANGER/Delay_Controls/Flange_Delay"));
--dcwi4
while (self.audioNode == null){ await wait(1000);}
OnNodeDisconnect(wblock,self.audioNode.parameters.get("/FLANGER/Delay_Controls/Flange_Delay"));
--wi5
while (self.audioNode == null){ await wait(1000);}
OnNodeConnect(wblock,self.audioNode.parameters.get("/FLANGER/Delay_Controls/Delay_Offset"));
--dcwi5
while (self.audioNode == null){ await wait(1000);}
OnNodeDisconnect(wblock,self.audioNode.parameters.get("/FLANGER/Delay_Controls/Delay_Offset"));
--wi6
while (self.audioNode == null){ await wait(1000);}
OnNodeConnect(wblock,self.audioNode.parameters.get("/FLANGER/0x00/Flanger_Output_Level"));
--dcwi6
while (self.audioNode == null){ await wait(1000);}
OnNodeDisconnect(wblock,self.audioNode.parameters.get("/FLANGER/0x00/Flanger_Output_Level"));
#df Flanger demo Faust Implementation
#i1 Set Speed [0-10]
#i2 Set Depth [0-1]
#i3 Set Feedback [-1:1]
#i4 Set Flange delay [0-20]
#i5 Set Delay Offset [0-20]
#i6 Set Level [-60:10]
faust~eqdemo
23
# Could get array as input. or be set for any of its input? 
--decl
inp(21)
outp(1)
#standart Faust WASM implementation
var pluginURL = 'sound/audioworklet/RIPFAUST/filterbank_demo/.';
var plugin = new filterbank_demo(audioContext, pluginURL);
var node = await plugin.load()
self.audioNode = node;
--code
for ( var i = 1 ; i < 21; i++ ) {
var parametername = "/CONSTANT-Q_FILTER_BANK__Butterworth_dyadic_tree_/0x00/";
if ( i < 10 ) { parametername += "Band_"+i;}else{parametername += "Band"+i;}
self.audioNode.setParamValue(parametername, mem(i))
}
--wi0
while (self.audioNode == null){ await wait(1000);}
OnNodeConnect(wblock,self.audioNode);
--dcwi0
while (self.audioNode == null){ await wait(1000);}
OnNodeDisconnect(wblock,self.audioNode);
#df EQ 20-band Faust Implementation
#i1 Pass array of numbers (decibels)
d~
22
# [d~] delayed gain node
#        
#                      *      time
#                      |      |  
#                    [~        ]
#                      |
--decl
inp(2)
outp(1)
self.audioNode =  audioContext.createDelay();
--ipf1
self.audioNode.delayTime.value = mem(1)
--wi0
OnNodeConnect(wblock,self.audioNode);
--dcwi0
OnNodeDisconnect(wblock,self.audioNode);
--wi1
OnNodeConnect(wblock,self.audioNode.delayTime);
--dcwi1
OnNodeDisconnect(wblock,self.audioNode.delayTime);
#df Delay audio signal
#i1 Set delay time in milliseconds
biquad~
41
--decl
inp(6)
outp(1)
self.audioNode = audioContext.createBiquadFilter();
self.audioNode.type = "lowpass";
--ipf1
self.audioNode .frequency.setValueAtTime(mem(1), audioContext.currentTime);
--ipf2
self.audioNode.Q.value = mem(2)
--ipf3
self.audioNode.gain.setValueAtTime(mem(3), audioContext.currentTime);
--ipf4
self.audioNode.detune.setValueAtTime(mem(4), audioContext.currentTime);
--ipf5
self.audioNode.type = mem(5)
--wi0
OnNodeConnect(wblock,self.audioNode);
--dcwi0
OnNodeDisconnect(wblock,self.audioNode);
--wi1
OnNodeConnect(wblock,self.audioNode.frequency);
--wi2
OnNodeConnect(wblock,self.audioNode.Q);
--wi3
OnNodeConnect(wblock,self.audioNode.gain);
--wi4
OnNodeConnect(wblock,self.audioNode.detune);
--dcwi1
OnNodeDisconnect(wblock,self.audioNode.frequency);
--dcwi2
OnNodeDisconnect(wblock,self.audioNode.Q);
--dcwi3
OnNodeDisconnect(wblock,self.audioNode.gain);
--dcwi4
OnNodeDisconnect(wblock,self.audioNode.detune);
#df Standart biquad filter
#i1 Set frequency
#i2 Set Resonnance
#i3 Set Gain
#i4 Set detune
#i5 Set type [lowpass,highpass,bandpass,peaking,notch]
comm
3
--decl
memset(1)
mem(1) = "comment"
stereo~
16
--decl
inp(2)
outp(1)
self.audioNode = audioContext.createStereoPanner();
--ipf1
self.audioNode.pan.setValueAtTime(mem(1), audioContext.currentTime);
--wi0
OnNodeConnect(wblock,self.audioNode);
--dcwi0
OnNodeDisconnect(wblock,self.audioNode);
--wi1
OnNodeConnect(wblock,self.audioNode.pan);
--dcwi1
OnNodeDisconnect(wblock,self.audioNode.pan);
#df A simpler audio panner
#i1 Apply panning [-1:1]
mic~
15
--decl
inp(1)
outp(1)
self.audioNode = audioContext.createGain();
if ( microphone == null && navigator.mediaDevices){
var stream = await navigator.mediaDevices.getUserMedia({"audio": true});
microphone = audioContext.createMediaStreamSource(stream);
}
while (microphone == null ) {await wait(1000);}
microphone.connect(self.audioNode)
--wi0
OnNodeConnect(wblock,self.audioNode);
--dcwi0
OnNodeDisconnect(wblock,self.audioNode);
#df Output audio signal from host microphone
faust~revecho
24
--decl
inp(2)
outp(1)
#standart Faust WASM implementation
var pluginURL = 'sound/audioworklet/RIPFAUST/reverse_echo/.';
var plugin = new reverse_echo(audioContext, pluginURL);
var node = await plugin.load()
self.audioNode = node;
--ipf1
self.audioNode.setParamValue("/reverse_echo/Log2_Delay_", mem(1));
--wi0
while (self.audioNode == null){ await wait(1000);}
OnNodeConnect(wblock,self.audioNode);
--dcwi0
while (self.audioNode == null){ await wait(1000);}
OnNodeDisconnect(wblock,self.audioNode);
--wi1
while (self.audioNode == null){ await wait(1000);}
OnNodeConnect(wblock,self.audioNode.parameters.get("/reverse_echo/Log2_Delay_"));
--dcwi1
while (self.audioNode == null){ await wait(1000);}
OnNodeDisconnect(wblock,self.audioNode.parameters.get("/reverse_echo/Log2_Delay_"));
#df Reverse echo Faust Implementation
#i1 Set log [5-16]
faust~pitch
42
--decl
inp(4)
outp(1)
#standart Faust WASM implementation
var pluginURL = 'sound/audioworklet/RIPFAUST/pitchshifter/.';
var plugin = new pitchshifter(audioContext, pluginURL);
var node = await plugin.load()
self.audioNode = node;
--ipf1
self.audioNode.setParamValue("/Pitch_Shifter/shift__semitones_", mem(1));
--ipf2
self.audioNode.setParamValue("/Pitch_Shifter/window__samples_", mem(2));
--ipf3
self.audioNode.setParamValue("/Pitch_Shifter/xfade__samples_", mem(3));
--wi0
while (self.audioNode == null){ await wait(1000);}
OnNodeConnect(wblock,self.audioNode);
--dcwi0
while (self.audioNode == null){ await wait(1000);}
OnNodeDisconnect(wblock,self.audioNode);
--wi1
while (self.audioNode == null){ await wait(1000);}
OnNodeConnect(wblock,self.audioNode.parameters.get("/Pitch_Shifter/shift__semitones_"));
--dcwi1
while (self.audioNode == null){ await wait(1000);}
OnNodeDisconnect(wblock,self.audioNode.parameters.get("/Pitch_Shifter/shift__semitones_"));
--wi2
while (self.audioNode == null){ await wait(1000);}
OnNodeConnect(wblock,self.audioNode.parameters.get("/Pitch_Shifter/window__samples_"));
--dcwi2
while (self.audioNode == null){ await wait(1000);}
OnNodeDisconnect(wblock,self.audioNode.parameters.get("/Pitch_Shifter/window__samples_"));
--wi3
while (self.audioNode == null){ await wait(1000);}
OnNodeConnect(wblock,self.audioNode.parameters.get("/Pitch_Shifter/xfade__samples_"));
--dcwi3
while (self.audioNode == null){ await wait(1000);}
OnNodeDisconnect(wblock,self.audioNode.parameters.get("/Pitch_Shifter/xfade__samples_"));
#df Pitch shifter Faust Implementation
#i1 Pitch semi-tones
#i2 Samples [0-10000]
#i3 XFade [0-10000]
faust~comp
60
--decl
inp(6)
outp(1)
#standart Faust WASM implementation
var pluginURL = 'sound/audioworklet/RIPFAUST/compressor_demo/.';
var plugin = new compressor_demo(audioContext, pluginURL);
var node = await plugin.load()
self.audioNode = node;
--ipf1
self.audioNode.setParamValue("/COMPRESSOR/0x00/Compression_Control/Ratio", mem(1));
--ipf2
self.audioNode.setParamValue("/COMPRESSOR/0x00/Compression_Control/Threshold", mem(2));
--ipf3
self.audioNode.setParamValue("/COMPRESSOR/0x00/Compression_Response/Attack", mem(3));
--ipf4
self.audioNode.setParamValue("/COMPRESSOR/0x00/Compression_Response/Release", mem(4));
--ipf5
self.audioNode.setParamValue("/COMPRESSOR/Makeup_Gain", mem(5));
--wi0
while (self.audioNode == null){ await wait(1000);}
OnNodeConnect(wblock,self.audioNode);
--dcwi0
while (self.audioNode == null){ await wait(1000);}
OnNodeDisconnect(wblock,self.audioNode);
--wi1
while (self.audioNode == null){ await wait(1000);}
OnNodeConnect(wblock,self.audioNode.parameters.get("/COMPRESSOR/0x00/Compression_Control/Ratio"));
--dcwi1
while (self.audioNode == null){ await wait(1000);}
OnNodeDisconnect(wblock,self.audioNode.parameters.get("/COMPRESSOR/0x00/Compression_Control/Ratio"));
--wi2
while (self.audioNode == null){ await wait(1000);}
OnNodeConnect(wblock,self.audioNode.parameters.get("/COMPRESSOR/0x00/Compression_Control/Threshold"));
--dcwi2
while (self.audioNode == null){ await wait(1000);}
OnNodeDisconnect(wblock,self.audioNode.parameters.get("/COMPRESSOR/0x00/Compression_Control/Threshold"));
--wi3
while (self.audioNode == null){ await wait(1000);}
OnNodeConnect(wblock,self.audioNode.parameters.get("/COMPRESSOR/0x00/Compression_Response/Attack"));
--dcwi3
while (self.audioNode == null){ await wait(1000);}
OnNodeDisconnect(wblock,self.audioNode.parameters.get("/COMPRESSOR/0x00/Compression_Response/Attack"));
--wi4
while (self.audioNode == null){ await wait(1000);}
OnNodeConnect(wblock,self.audioNode.parameters.get("/COMPRESSOR/0x00/Compression_Response/Release"));
--dcwi4
while (self.audioNode == null){ await wait(1000);}
OnNodeDisconnect(wblock,self.audioNode.parameters.get("/COMPRESSOR/0x00/Compression_Response/Release"));
--wi5
while (self.audioNode == null){ await wait(1000);}
OnNodeConnect(wblock,self.audioNode.parameters.get("/COMPRESSOR/Makeup_Gain"));
--dcwi5
while (self.audioNode == null){ await wait(1000);}
OnNodeDisconnect(wblock,self.audioNode.parameters.get("/COMPRESSOR/Makeup_Gain"));
#df Faust Implementation of signal compressor
#i1 Ratio in db[1-20]
#i2 Treshold in db[-100:10]
#i3 Attack in ms
#i4 Release in ms
#i5 Gain in db[-96:96]
faust~freeverb
51
--decl
inp(5)
outp(1)
#standart Faust WASM implementation
var pluginURL = 'sound/audioworklet/RIPFAUST/freeverb/.';
var plugin = new freeverb(audioContext, pluginURL);
var node = await plugin.load()
self.audioNode = node;
--ipf1
self.audioNode.setParamValue("/Freeverb/0x00/Damp", mem(1));
--ipf2
self.audioNode.setParamValue("/Freeverb/0x00/RoomSize", mem(2));
--ipf3
self.audioNode.setParamValue("/Freeverb/0x00/Stereo_Spread", mem(3));
--ipf4
self.audioNode.setParamValue("/Freeverb/Wet", mem(4));
--wi0
while (self.audioNode == null){ await wait(1000);}
OnNodeConnect(wblock,self.audioNode);
--dcwi0
while (self.audioNode == null){ await wait(1000);}
OnNodeDisconnect(wblock,self.audioNode);
--wi1
while (self.audioNode == null){ await wait(1000);}
OnNodeConnect(wblock,self.audioNode.parameters.get("/Freeverb/0x00/Damp"));
--dcwi1
while (self.audioNode == null){ await wait(1000);}
OnNodeDisconnect(wblock,self.audioNode.parameters.get("/Freeverb/0x00/Damp"));
--wi2
while (self.audioNode == null){ await wait(1000);}
OnNodeConnect(wblock,self.audioNode.parameters.get("/Freeverb/0x00/RoomSize"));
--dcwi2
while (self.audioNode == null){ await wait(1000);}
OnNodeDisconnect(wblock,self.audioNode.parameters.get("/Freeverb/0x00/RoomSize"));
--wi3
while (self.audioNode == null){ await wait(1000);}
OnNodeConnect(wblock,self.audioNode.parameters.get("/Freeverb/0x00/Stereo_Spread"));
--dcwi3
while (self.audioNode == null){ await wait(1000);}
OnNodeDisconnect(wblock,self.audioNode.parameters.get("/Freeverb/0x00/Stereo_Spread"));
--wi4
while (self.audioNode == null){ await wait(1000);}
OnNodeConnect(wblock,self.audioNode.parameters.get("/Freeverb/Wet"));
--dcwi4
while (self.audioNode == null){ await wait(1000);}
OnNodeDisconnect(wblock,self.audioNode.parameters.get("/Freeverb/Wet"));
#df Freeverb module from Faust 
#i1 Damp [0-1]
#i2 Roomsize [0-1]
#i3 Stereo dispersion [0-1]
#i4 Wet [0-1]
faust~phaser2
87
--decl
inp(9)
outp(1)
#standart Faust WASM implementation
var pluginURL = 'sound/audioworklet/RIPFAUST/phaser2/.';
var plugin = new phaser2(audioContext, pluginURL);
var node = await plugin.load()
self.audioNode = node;
--ipf1
self.audioNode.setParamValue("/PHASER2/0x00/Speed", mem(1));
--ipf2
self.audioNode.setParamValue("/PHASER2/0x00/Notch_Depth__Intensity_", mem(2));
--ipf3
self.audioNode.setParamValue("/PHASER2/0x00/Feedback_Gain", mem(3));
--ipf4
self.audioNode.setParamValue("/PHASER2/0x00/Notch_width", mem(4));
--ipf5
self.audioNode.setParamValue("/PHASER2/0x00/Min_Notch1_Freq", mem(5));
--ipf6
self.audioNode.setParamValue("/PHASER2/0x00/Max_Notch1_Freq", mem(6));
--ipf7
self.audioNode.setParamValue("/PHASER2/0x00/Notch_Freq_Ratio:_NotchFreq_n+1_/NotchFreq_n_", mem(7));
--ipf8
self.audioNode.setParamValue("/PHASER2/0x00/Phaser_Output_Level", mem(8));
--wi0
while (self.audioNode == null){ await wait(1000);}
OnNodeConnect(wblock,self.audioNode);
--dcwi0
while (self.audioNode == null){ await wait(1000);}
OnNodeDisconnect(wblock,self.audioNode);
--wi1
while (self.audioNode == null){ await wait(1000);}
OnNodeConnect(wblock,self.audioNode.parameters.get("/PHASER2/0x00/Speed"));
--dcwi1
while (self.audioNode == null){ await wait(1000);}
OnNodeDisconnect(wblock,self.audioNode.parameters.get("/PHASER2/0x00/Speed"));
--wi2
while (self.audioNode == null){ await wait(1000);}
OnNodeConnect(wblock,self.audioNode.parameters.get("/PHASER2/0x00/Notch_Depth__Intensity_"));
--dcwi2
while (self.audioNode == null){ await wait(1000);}
OnNodeDisconnect(wblock,self.audioNode.parameters.get("/PHASER2/0x00/Notch_Depth__Intensity_"));
--wi3
while (self.audioNode == null){ await wait(1000);}
OnNodeConnect(wblock,self.audioNode.parameters.get("/PHASER2/0x00/Feedback_Gain"));
--dcwi3
while (self.audioNode == null){ await wait(1000);}
OnNodeDisconnect(wblock,self.audioNode.parameters.get("/PHASER2/0x00/Feedback_Gain"));
--wi4
while (self.audioNode == null){ await wait(1000);}
OnNodeConnect(wblock,self.audioNode.parameters.get("/PHASER2/0x00/Notch_width"));
--dcwi4
while (self.audioNode == null){ await wait(1000);}
OnNodeDisconnect(wblock,self.audioNode.parameters.get("/PHASER2/0x00/Notch_width"));
--wi5
while (self.audioNode == null){ await wait(1000);}
OnNodeConnect(wblock,self.audioNode.parameters.get("/PHASER2/0x00/Min_Notch1_Freq"));
--dcwi5
while (self.audioNode == null){ await wait(1000);}
OnNodeDisconnect(wblock,self.audioNode.parameters.get("/PHASER2/0x00/Min_Notch1_Freq"));
--wi6
while (self.audioNode == null){ await wait(1000);}
OnNodeConnect(wblock,self.audioNode.parameters.get("/PHASER2/0x00/Max_Notch1_Freq"));
--dcwi6
while (self.audioNode == null){ await wait(1000);}
OnNodeDisconnect(wblock,self.audioNode.parameters.get("/PHASER2/0x00/Max_Notch1_Freq"));
--wi7
while (self.audioNode == null){ await wait(1000);}
OnNodeConnect(wblock,self.audioNode.parameters.get("/PHASER2/0x00/Notch_Freq_Ratio:_NotchFreq_n+1_/NotchFreq_n_"));
--dcwi7
while (self.audioNode == null){ await wait(1000);}
OnNodeDisconnect(wblock,self.audioNode.parameters.get("/PHASER2/0x00/Notch_Freq_Ratio:_NotchFreq_n+1_/NotchFreq_n_"));
--wi8
while (self.audioNode == null){ await wait(1000);}
OnNodeConnect(wblock,self.audioNode.parameters.get("/PHASER2/0x00/Phaser_Output_Level"));
--dcwi8
while (self.audioNode == null){ await wait(1000);}
OnNodeDisconnect(wblock,self.audioNode.parameters.get("/PHASER2/0x00/Phaser_Output_Level"));
#df Phaser implementation using notch filter
#i1 Speed in hertz [0-10]
#i2 Notch depth [0-1]
#i3 Feedback gain [-1:0]
#i4 Notch width [0-5000]
#i5 Notch minimum frequency
#i6 Notch maximum frequency
#i7 Notch frequency ratio [1-4]
#i8 Ouput level in db
float
7
--decl
inp(1)
outp(1)
--code
mem(0) = parseFloat(mem(0))
out0(0)
#df Convert a string to a float
ob~bpf
33
--decl
inp(3)
outp(1)
#standart Faust WASM implementation
var pluginURL = 'sound/audioworklet/RIPFAUST/oberheimBPF/.';
var plugin = new oberheimBPF(audioContext, pluginURL);
var node = await plugin.load()
self.audioNode = node;
--ipf1
self.audioNode.setParamValue("/oberheimBPF/freq", mem(1));
--ipf2
self.audioNode.setParamValue("/oberheimBPF/reso", mem(2));
--wi0
while (self.audioNode == null){ await wait(1000);}
OnNodeConnect(wblock,self.audioNode);
--dcwi0
while (self.audioNode == null){ await wait(1000);}
OnNodeDisconnect(wblock,self.audioNode);
--wi1
while (self.audioNode == null){ await wait(1000);}
OnNodeConnect(wblock,self.audioNode.parameters.get("/oberheimBPF/freq"));
--dcwi1
while (self.audioNode == null){ await wait(1000);}
OnNodeDisconnect(wblock,self.audioNode.parameters.get("/oberheimBPF/freq"));
--wi2
while (self.audioNode == null){ await wait(1000);}
OnNodeConnect(wblock,self.audioNode.parameters.get("/oberheimBPF/reso"));
--dcwi2
while (self.audioNode == null){ await wait(1000);}
OnNodeDisconnect(wblock,self.audioNode.parameters.get("/oberheimBPF/reso"));
#df Oberheim band pass filter
#i1 Set frequency normalized [0-1]
#i2 Set resonnance [0-200]
ob~hpf
33
--decl
inp(3)
outp(1)
#standart Faust WASM implementation
var pluginURL = 'sound/audioworklet/RIPFAUST/oberheimHPF/.';
var plugin = new oberheimHPF(audioContext, pluginURL);
var node = await plugin.load()
self.audioNode = node;
--ipf1
self.audioNode.setParamValue("/oberheimHPF/freq", mem(1));
--ipf2
self.audioNode.setParamValue("/oberheimHPF/reso", mem(2));
--wi0
while (self.audioNode == null){ await wait(1000);}
OnNodeConnect(wblock,self.audioNode);
--dcwi0
while (self.audioNode == null){ await wait(1000);}
OnNodeDisconnect(wblock,self.audioNode);
--wi1
while (self.audioNode == null){ await wait(1000);}
OnNodeConnect(wblock,self.audioNode.parameters.get("/oberheimHPF/freq"));
--dcwi1
while (self.audioNode == null){ await wait(1000);}
OnNodeDisconnect(wblock,self.audioNode.parameters.get("/oberheimHPF/freq"));
--wi2
while (self.audioNode == null){ await wait(1000);}
OnNodeConnect(wblock,self.audioNode.parameters.get("/oberheimHPF/reso"));
--dcwi2
while (self.audioNode == null){ await wait(1000);}
OnNodeDisconnect(wblock,self.audioNode.parameters.get("/oberheimHPF/reso"));
#df Oberheim high pass filter
#i1 Set frequency normalized [0-1]
#i2 Set resonnance [0-200]
ob~lpf
33
--decl
inp(3)
outp(1)
#standart Faust WASM implementation
var pluginURL = 'sound/audioworklet/RIPFAUST/oberheimLPF/.';
var plugin = new oberheimLPF(audioContext, pluginURL);
var node = await plugin.load()
self.audioNode = node;
--ipf1
self.audioNode.setParamValue("/oberheimLPF/freq", mem(1));
--ipf2
self.audioNode.setParamValue("/oberheimLPF/reso", mem(2));
--wi0
while (self.audioNode == null){ await wait(1000);}
OnNodeConnect(wblock,self.audioNode);
--dcwi0
while (self.audioNode == null){ await wait(1000);}
OnNodeDisconnect(wblock,self.audioNode);
--wi1
while (self.audioNode == null){ await wait(1000);}
OnNodeConnect(wblock,self.audioNode.parameters.get("/oberheimLPF/freq"));
--dcwi1
while (self.audioNode == null){ await wait(1000);}
OnNodeDisconnect(wblock,self.audioNode.parameters.get("/oberheimLPF/freq"));
--wi2
while (self.audioNode == null){ await wait(1000);}
OnNodeConnect(wblock,self.audioNode.parameters.get("/oberheimLPF/reso"));
--dcwi2
while (self.audioNode == null){ await wait(1000);}
OnNodeDisconnect(wblock,self.audioNode.parameters.get("/oberheimLPF/reso"));
#df Oberheim low pass filter
#i1 Set frequency normalized [0-1]
#i2 Set resonnance [0-200]
bang~
18
--decl
inp(2)
outp(1)
await audioContext.audioWorklet.addModule("sound/audioworklet/audiobang.js");
self.audioNode = new AudioWorkletNode(audioContext,"audio-bang-processor");
self.audioNode.port.onmessage = (event) =>{self.OIO()}
--code
out0(0)
--ipf1
self.audioNode.parameters.get('exciter').value = mem(1)
--wi0
while (self.audioNode == null){ await wait(1000);}
OnNodeConnect(wblock,self.audioNode);
--dcwi0
while (self.audioNode == null){ await wait(1000);}
OnNodeDisconnect(wblock,self.audioNode);
#df Bang when signal amplitude above value
#i1 Set value
faust~cubicnl
33
--decl
inp(3)
outp(1)
#standart Faust WASM implementation
var pluginURL = 'sound/audioworklet/RIPFAUST/cubicnl/.';
var plugin = new cubicnl(audioContext, pluginURL);
var node = await plugin.load()
self.audioNode = node;
--ipf1
self.audioNode.setParamValue("/CUBIC_NONLINEARITY_cubicnl/Drive", mem(1));
--ipf2
self.audioNode.setParamValue("/CUBIC_NONLINEARITY_cubicnl/Offset", mem(2));
--wi0
while (self.audioNode == null){ await wait(1000);}
OnNodeConnect(wblock,self.audioNode);
--dcwi0
while (self.audioNode == null){ await wait(1000);}
OnNodeDisconnect(wblock,self.audioNode);
--wi1
while (self.audioNode == null){ await wait(1000);}
OnNodeConnect(wblock,self.audioNode.parameters.get("/CUBIC_NONLINEARITY_cubicnl/Drive"));
--dcwi1
while (self.audioNode == null){ await wait(1000);}
OnNodeDisconnect(wblock,self.audioNode.parameters.get("/CUBIC_NONLINEARITY_cubicnl/Drive"));
--wi2
while (self.audioNode == null){ await wait(1000);}
OnNodeConnect(wblock,self.audioNode.parameters.get("/CUBIC_NONLINEARITY_cubicnl/Offset"));
--dcwi2
while (self.audioNode == null){ await wait(1000);}
OnNodeDisconnect(wblock,self.audioNode.parameters.get("/CUBIC_NONLINEARITY_cubicnl/Offset"));
#df Cubic non-linear distorstion from Faust
#i1 Set drive [0-1]
#i2 Set harmonics offset [0-1]
ceil
7
--decl
inp(1)
outp(1)
--code
mem(0) = Math.ceil(mem(0))
out0(0)
#df Output highest integer from a float value
noise~
13
--decl
inp(0)
outp(1)
await audioContext.audioWorklet.addModule("sound/audioworklet/noise.js");
self.audioNode = new AudioWorkletNode(audioContext,"random-noise-processor");
console.log("noise created!")
--wi0
while (self.audioNode == null){ await wait(1000);}
OnNodeConnect(wblock,self.audioNode);
--dcwi0
while (self.audioNode == null){ await wait(1000);}
OnNodeDisconnect(wblock,self.audioNode);
#df Output random audio signal
sha2bin
8
#df Output array of 32 number between 0-255 from a sha256 string
--decl
inp(1)
outp(1)
memset(2)
--code
mem(1) = SHA2Binary(mem(0))
out0(1)
clamp~
12
--decl
inp(1)
outp(1)
await audioContext.audioWorklet.addModule("sound/audioworklet/clamp.js");
self.audioNode = new AudioWorkletNode(audioContext,"audio-clamp-processor");
--wi0
while (self.audioNode == null){ await wait(1000);}
OnNodeConnect(wblock,self.audioNode);
--dcwi0
while (self.audioNode == null){ await wait(1000);}
OnNodeDisconnect(wblock,self.audioNode);
#df Clamp oscillator signal between 0 and 1
cos~
12
--decl
inp(1)
outp(1)
await audioContext.audioWorklet.addModule("sound/audioworklet/cos.js");
self.audioNode = new AudioWorkletNode(audioContext,"audio-cos-processor");
--wi0
while (self.audioNode == null){ await wait(1000);}
OnNodeConnect(wblock,self.audioNode);
--dcwi0
while (self.audioNode == null){ await wait(1000);}
OnNodeDisconnect(wblock,self.audioNode);
#df Output cosine of 2PI * signal input
sig~
13
--decl
inp(1)
outp(1)
memset(2)
await audioContext.audioWorklet.addModule("sound/audioworklet/sig.js");
self.audioNode = new AudioWorkletNode(audioContext,"audio-sig-processor");
--code
self.audioNode.parameters.get("offset").setValueAtTime(mem(0), audioContext.currentTime);
--ipf1 
#wrapper for rename argument
while (self.audioNode == null){ await wait(1000);}
self.audioNode.parameters.get("offset").setValueAtTime(mem(1), audioContext.currentTime);
#df Convert number to constant audio signal
oscillo~
25
--decl
inp(4)
mem(1) = 600
mem(2) = 10
self.analyser = audioContext.createAnalyser();
# connect it to something
# set default parameters
self.analyser.fftSize = 2048;
self.bufferLength = self.analyser.frequencyBinCount;
self.dataArray = new Uint8Array(self.bufferLength);
self.On = true;
# Record the object to sound visualizers object in sound.js
AddOscilloToDraw(self)
--ipf3
self.On = !self.On
--wi0
while (self.analyser == null){ await wait(1000);}
OnNodeConnect(wblock,self.analyser);
--dcwi0
while (self.analyser == null){ await wait(1000);}
OnNodeDisconnect(wblock,self.analyser);
#df Draw a signal on screen
#i1 Screen size
#i2 Line size
#i3 On/Off
cos
7
--decl
inp(1)
outp(1)
--code
mem(0) = Math.cos(mem(0))
out0(0)
#df Output cosinus of a value
+~
22
# we should be able to directly write value...
--decl
inp(2)
outp(1)
await audioContext.audioWorklet.addModule("sound/audioworklet/add.js");
self.audioNode = new AudioWorkletNode(audioContext,"audio-add-processor",{numberOfInputs: 2,numberOfOutputs: 1,});
--ipf1
while (self.audioNode == null){ await wait(1000);}
self.audioNode.parameters.get("defaultvalue").setValueAtTime(mem(1), audioContext.currentTime);
--wi0
while (self.audioNode == null){ await wait(1000);}
OnNodeConnect(wblock,self.audioNode,0,0);
--dcwi0
while (self.audioNode == null){ await wait(1000);}
OnNodeDisconnect(wblock,self.audioNode,0,0);
--wi1
while (self.audioNode == null){ await wait(1000);}
OnNodeConnectSpecific(wblock,self.audioNode,0,1);
--dcwi1
while (self.audioNode == null){ await wait(1000);}
OnNodeDisconnectSpecific(wblock,self.audioNode,0,1);
#df Add 2 audio signals
*~
22
# we should be able to directly write value...
--decl
inp(2)
outp(1)
await audioContext.audioWorklet.addModule("sound/audioworklet/mul.js");
self.audioNode = new AudioWorkletNode(audioContext,"audio-mul-processor",{numberOfInputs: 2,numberOfOutputs: 1,});
--ipf1
while (self.audioNode == null){ await wait(1000);}
self.audioNode.parameters.get("defaultvalue").setValueAtTime(mem(1), audioContext.currentTime);
--wi0
while (self.audioNode == null){ await wait(1000);}
OnNodeConnect(wblock,self.audioNode,0,0);
--dcwi0
while (self.audioNode == null){ await wait(1000);}
OnNodeDisconnect(wblock,self.audioNode,0,0);
--wi1
while (self.audioNode == null){ await wait(1000);}
OnNodeConnectSpecific(wblock,self.audioNode,0,1);
--dcwi1
while (self.audioNode == null){ await wait(1000);}
OnNodeDisconnectSpecific(wblock,self.audioNode,0,1);
#df Multiply 2 audio signals
-~
22
# we should be able to directly write value...
--decl
inp(2)
outp(1)
await audioContext.audioWorklet.addModule("sound/audioworklet/sub.js");
self.audioNode = new AudioWorkletNode(audioContext,"audio-sub-processor",{numberOfInputs: 2,numberOfOutputs: 1,});
--ipf1
while (self.audioNode == null){ await wait(1000);}
self.audioNode.parameters.get("defaultvalue").setValueAtTime(mem(1), audioContext.currentTime);
--wi0
while (self.audioNode == null){ await wait(1000);}
OnNodeConnect(wblock,self.audioNode,0,0);
--dcwi0
while (self.audioNode == null){ await wait(1000);}
OnNodeDisconnect(wblock,self.audioNode,0,0);
--wi1
while (self.audioNode == null){ await wait(1000);}
OnNodeConnectSpecific(wblock,self.audioNode,0,1);
--dcwi1
while (self.audioNode == null){ await wait(1000);}
OnNodeDisconnectSpecific(wblock,self.audioNode,0,1);
#df Sub 2 audio signals
/~
22
# we should be able to directly write value...
--decl
inp(2)
outp(1)
await audioContext.audioWorklet.addModule("sound/audioworklet/div.js");
self.audioNode = new AudioWorkletNode(audioContext,"audio-div-processor",{numberOfInputs: 2,numberOfOutputs: 1,});
--ipf1
while (self.audioNode == null){ await wait(1000);}
self.audioNode.parameters.get("defaultvalue").setValueAtTime(mem(1), audioContext.currentTime);
--wi0
while (self.audioNode == null){ await wait(1000);}
OnNodeConnect(wblock,self.audioNode,0,0);
--dcwi0
while (self.audioNode == null){ await wait(1000);}
OnNodeDisconnect(wblock,self.audioNode,0,0);
--wi1
while (self.audioNode == null){ await wait(1000);}
OnNodeConnectSpecific(wblock,self.audioNode,0,1);
--dcwi1
while (self.audioNode == null){ await wait(1000);}
OnNodeDisconnectSpecific(wblock,self.audioNode,0,1);
#df Divide 2 audio signals
min~
22
# we should be able to directly write value...
--decl
inp(2)
outp(1)
await audioContext.audioWorklet.addModule("sound/audioworklet/min.js");
self.audioNode = new AudioWorkletNode(audioContext,"audio-min-processor",{numberOfInputs: 2,numberOfOutputs: 1,});
--ipf1
while (self.audioNode == null){ await wait(1000);}
self.audioNode.parameters.get("defaultvalue").setValueAtTime(mem(1), audioContext.currentTime);
--wi0
while (self.audioNode == null){ await wait(1000);}
OnNodeConnect(wblock,self.audioNode,0,0);
--dcwi0
while (self.audioNode == null){ await wait(1000);}
OnNodeDisconnect(wblock,self.audioNode,0,0);
--wi1
while (self.audioNode == null){ await wait(1000);}
OnNodeConnectSpecific(wblock,self.audioNode,0,1);
--dcwi1
while (self.audioNode == null){ await wait(1000);}
OnNodeDisconnectSpecific(wblock,self.audioNode,0,1);
#df Ouput lesser signal
max~
22
# we should be able to directly write value...
--decl
inp(2)
outp(1)
await audioContext.audioWorklet.addModule("sound/audioworklet/max.js");
self.audioNode = new AudioWorkletNode(audioContext,"audio-max-processor",{numberOfInputs: 2,numberOfOutputs: 1,});
--ipf1
while (self.audioNode == null){ await wait(1000);}
self.audioNode.parameters.get("defaultvalue").setValueAtTime(mem(1), audioContext.currentTime);
--wi0
while (self.audioNode == null){ await wait(1000);}
OnNodeConnect(wblock,self.audioNode,0,0);
--dcwi0
while (self.audioNode == null){ await wait(1000);}
OnNodeDisconnect(wblock,self.audioNode,0,0);
--wi1
while (self.audioNode == null){ await wait(1000);}
OnNodeConnectSpecific(wblock,self.audioNode,0,1);
--dcwi1
while (self.audioNode == null){ await wait(1000);}
OnNodeDisconnectSpecific(wblock,self.audioNode,0,1);
#df Ouput loudest signal
faust~phasor
24
--decl
inp(3)
outp(1)
#standart Faust WASM implementation
var pluginURL = 'sound/audioworklet/RIPFAUST/phasor/.';
var plugin = new phasor(audioContext, pluginURL);
var node = await plugin.load()
self.audioNode = node;
--ipf1
self.audioNode.setParamValue("/phasor/freq", mem(1));
--wi0
while (self.audioNode == null){ await wait(1000);}
OnNodeConnect(wblock,self.audioNode);
--dcwi0
while (self.audioNode == null){ await wait(1000);}
OnNodeDisconnect(wblock,self.audioNode);
--wi1
while (self.audioNode == null){ await wait(1000);}
OnNodeConnect(wblock,self.audioNode.parameters.get("/phasor/freq"));
--dcwi1
while (self.audioNode == null){ await wait(1000);}
OnNodeDisconnect(wblock,self.audioNode.parameters.get("/phasor/freq"));
#df Faust implementation of Phasor
#i1 Set Frequency
phasor~
22
--decl
inp(2)
outp(1)
await audioContext.audioWorklet.addModule("sound/audioworklet/phasor.js");
self.audioNode = new AudioWorkletNode(audioContext,"phasor-processor");
--ipf1
while (self.audioNode == null){ await wait(1000);}
self.audioNode.parameters.get("frequency").setValueAtTime(mem(1), audioContext.currentTime);
--wi0
while (self.audioNode == null){ await wait(1000);}
OnNodeConnect(wblock,self.audioNode);
--dcwi0
while (self.audioNode == null){ await wait(1000);}
OnNodeDisconnect(wblock,self.audioNode);
--wi1
while (self.audioNode == null){ await wait(1000);}
OnNodeConnect(wblock,self.audioNode.parameters.get("frequency"));
--dcwi1
while (self.audioNode == null){ await wait(1000);}
OnNodeDisconnect(wblock,self.audioNode.parameters.get("frequency"));
#df Linear ramp audio signal
#i1 Set frequency
line~
24
# [line~] ramp signal value over time 
#        
#                      
#                      |        
#                    [line~        ]
#                      |
--decl
inp(1)
outp(1)
self.audioNode =  audioContext.createGain();
self.audioNode.gain.value = 0;
--code
mem(0) = mem(0).split(' ')
var t = parseFloat(mem(0)[1]) / 1000
self.audioNode.gain.linearRampToValueAtTime(parseFloat(mem(0)[0]), audioContext.currentTime + t);
self.audioNode.value= 1
--ipf1
self.audioNode.gain.value = mem(1)
--wi0
OnNodeConnect(wblock,self.audioNode);
--dcwi0
OnNodeDisconnect(wblock,self.audioNode);
#df Ramp signal over time
#i0 A packed-string containing amplitude to reach and time as ms
packstr
20
# packstr a number of values into a single string. number of input 
# bang at 0
# declare number of inputs using packstr 8 or packstr 16...
--decl
inp(1)
outp(1)
memset(2)
--code
mem(0)="";
for ( var i = 1; i < self.memory.length;i++){mem(0)+=mem(i)+" ";}
out0(0)
--arg
# access argument using arg
# we received arguments values.
var n = parseInt(arg)
n++;
inp(n)
#reinit memory
for ( var i = 0; i < self.memory.length;i++){mem(i)=0}
#df Pack a list of values into a single string
pack
21
# pack a number of values into a single string. number of input 
# bang at 0
# declare number of inputs using packstr 8 or packstr 16...
--decl
inp(1)
outp(1)
memset(2)
--code
mem(0)=new Array();
for ( var i = 1; i < self.memory.length;i++){mem(0).push(mem(i))}
out0(0)
--arg
# access argument using arg
# we received arguments values.
console.log("received " + arg);
var n = parseInt(arg)
n++;
inp(n)
#reinit memory
for ( var i = 0; i < self.memory.length;i++){mem(i)=0}
#df Pack a list of values into a single array
adsr~
28
--decl
inp(6)
outp(1)
await audioContext.audioWorklet.addModule("sound/audioworklet/sig.js");
self.audioNode = new AudioWorkletNode(audioContext,"audio-sig-processor");
self.audioNode.parameters.get("offset").setValueAtTime(1, audioContext.currentTime);
--code
var t = audioContext.currentTime;
var peak = mem(1)
var sus   = mem(1) * (mem(4)/100)
if (mem(0) > 0) {
# should I use set value at time 0 here ?
t+= parseFloat(mem(2)) / 1000
self.audioNode.parameters.get("offset").linearRampToValueAtTime(peak, t);
t+= parseFloat(mem(3)) / 1000
self.audioNode.parameters.get("offset").linearRampToValueAtTime(sus, t);
}else{
t+= parseFloat(mem(5)) / 1000
self.audioNode.parameters.get("offset").linearRampToValueAtTime(0, t);
}
# Use Sig to create the default sound.
#df Fast implementation of standart ADSR enveloppe
#i0 Trigger attack if above 0 else trigger release
#i1 Peak level
#i2 Attack time in ms
#i3 Decay time in ms
#i4 Sustain level as pourcentage of peak level
#i5 Release time in ms
unpack
9
#df Unpack array and bang from multiple outputs
--decl
inp(1)
memset(2)
--code
for ( var i = 0; i < mem(0).length; i++){self.O_true(i,mem(0)[i]);}
--arg
var n = parseInt(arg)
outp(n)
sin
7
--decl
inp(1)
outp(1)
--code
mem(0) = Math.sin(mem(0))
out0(0)
#df Output sinus of a value
v3
10
#df Output a vector3 value
#i1 Set x
#i2 Set y
#i3 Set z
--decl
inp(4)
outp(1)
--code
mem(0) = [mem(1),mem(2),mem(3)]
out0(0)
v3*
12
#df Multiply vector by x,y,z
#i1 Set x
#i2 Set y
#i3 Set z
--decl
inp(4)
outp(1)
--code
mem(0)[0] *= mem(1)
mem(0)[1] *= mem(2)
mem(0)[2] *= mem(3)
out0(0)
v3+
12
#df Add vector by x,y,z
#i1 Set x
#i2 Set y
#i3 Set z
--decl
inp(4)
outp(1)
--code
mem(0)[0] += mem(1)
mem(0)[1] += mem(2)
mem(0)[2] += mem(3)
out0(0)
v3add
13
#df Add 2 vectors
#i1 Set x
#i2 Set y
#i3 Set z
--decl
inp(2)
outp(1)
mem(1) = [0,0,0]
--code
mem(0)[0] += mem(1)[0] 
mem(0)[1] += mem(1)[1] 
mem(0)[2] += mem(1)[2] 
out0(0)
v3mul
13
#df Multiply 2 vectors
#i1 Set x
#i2 Set y
#i3 Set z
--decl
inp(2)
outp(1)
mem(1) = [1,1,1]
--code
mem(0)[0] *= mem(1)[0] 
mem(0)[1] *= mem(1)[1] 
mem(0)[2] *= mem(1)[2] 
out0(0)
v2mat
16
#df Multiply vector by a 4x4 Matrix
#i1 Set matrix
--decl
inp(2)
outp(1)
--code
var x = 0.0
var y = 0.0
var z = 0.0
x = mem(0)[0] * mem(1)[0][0] + mem(0)[1] * mem(1)[1][0] + mem(0)[2] * mem(1)[2][0] + mem(1)[3][0]
y = mem(0)[0] * mem(1)[0][1] + mem(0)[1] * mem(1)[1][1] + mem(0)[2] * mem(1)[2][1] + mem(1)[3][1];
z  = mem(0)[0] * mem(1)[0][2] + mem(0)[1] * mem(1)[1][2] +mem(0)[2] * mem(1)[2][2] + mem(1)[3][2];
var w = mem(0)[0] * mem(1)[0][3];
if (w != 0.0){x /= w; y /= w; z /= w;}
mem(0) = [x,y,z]
out0(0)
matrix
34
#a matrix of 4x4 is array[4] of array[4]. we can set value like 
#bang flush the matrix.
#df Output a matrix of mutliple dimension
--decl
outp(1)
memset(3)
self.matrix = new Array();
--code
var ctr = 1
for ( var y = 0 ; y < self.ySize; y++){
for ( var x = 0 ; x < self.xSize; x++){
self.matrix[y][x] = mem(ctr)
ctr++
}
}
mem(0) = self.matrix;
out0(0)
--arg
console.log("ctr : "+ argctr +" arg : " + arg)
#set up First dimension
if ( argctr == 1){
self.matrix = new Array(arg)
self.xSize = arg;
}
#Set up second dimension
if ( argctr == 2) {
var ctr = 0; 
for ( var i = 0; i < self.matrix.length; i++){
self.matrix[i] = new Array(arg);
ctr+=arg;
}
self.ySize = arg;
inp(ctr+3)
}
list
5
#df Store values in an array
#          r  wr  i
#          |  |   |
#          [list    ]
#          |
3dcube
52
#df 3D-cube of 36 vertices for projection test
#          r       i
#          |      |
#          [3dcube    ]
#          |
--decl
inp(2)
outp(1)
memset(3)
var a = new Array();
a.push([0,0,0]) 
a.push([0,1,0])
a.push([1,1,0])
a.push([0,0,0])
a.push([1,1,0])
a.push([1,0,0])
a.push([1,0,0])
a.push([1,1,0])
a.push([1,1,1])
a.push([1,0,0])
a.push([1,1,1])
a.push([1,0,1])
a.push([1,0,1])
a.push([1,1,1])
a.push([0,1,1])
a.push([1,0,1])
a.push([0,1,1])
a.push([0,0,1])
a.push([0,0,1])
a.push([0,1,1])
a.push([0,1,0])
a.push([0,0,1])
a.push([0,1,0])
a.push([0,0,0])
a.push([0,1,0])
a.push([0,1,1])
a.push([1,1,1])
a.push([0,1,0])
a.push([1,1,1])
a.push([1,1,1])
a.push([1,0,1])
a.push([0,0,1])
a.push([0,0,0])
a.push([1,0,1])
a.push([0,0,0])
a.push([1,0,0])
mem(2) =a
--code
mem(0) = mem(2)[mem(1)]
out0(0)
#i0 Read at index
#i1 Set index
opline
13
--decl 
inp(5)
outp(1)
mem(3) = GetColor(255,255,255)
mem(4) = 3
--code
OutputCanvas.OpenLine(mem(1),mem(2),mem(3),mem(4))
out0(0)
#df Start path at position
#i1 Set x
#i2 Set y
#i3 Set color
#i4 Set line width
ctline
9
--decl 
inp(3)
outp(1)
--code
OutputCanvas.MoveLine(mem(1),mem(2))
out0(0)
#df Stroke path at position
#i1 Set x
#i2 Set y
loopi
7
#df Bang its output a specific amount of time
--decl
inp(2)
outp(1)
--code
for ( var i = 0 ; i < mem(1); i++) {self.O_true(0,i);}
#i1 Set number of times
html
8
#df Request HTML content
--decl
inp(1)
outp(1)
--code
mem(0) =  await fetch(mem(0))
out0(0)
#i0 Set html link
htmltxt
7
#df Output text component of an HTML response
--decl
inp(1)
outp(1)
--code
mem(0) =  await mem(0).text();
out0(0)
.obj
47
#df Store .obj data from a .obj file data
#v   i   vd   ln    loa
#|   |   |     |     |
#[ .obj            ] 
# |   |   |     |
#i0 Output vector3 data from indices number
#i1 Output indice value at given index
#i2 Output vector3 value at given index
#i3 Output indices count
#i4 Load OBJ data from text
--decl
inp(5)
outp(4)
--code
# Output vector3 from a given indices
var indice = self.OBJ[1][mem(0)]
mem(0)=self.OBJ[0][indice]
out0(0)
--ipf1
# Output indice value
mem(1) = self.OBJ[1][mem(1)]
out1(1)
--ipf2
# Output vector value
mem(2) = self.OBJ[0][mem(2)]
out2(2)
--ipf3
mem(3) =  self.OBJ[1].length;
out3(3)
--ipf4
# parse .OBJ
var t = mem(4).split("\n");
var verts = new Array()
var indices = new Array()
for ( var i = 0 ; i < t.length ; i++){
if ( t[i][0] == 'v'){
var param = t[i].substr(1,t[i].length -1 );
param = param.split(' ');
var vec3 = new Array();
for ( var n = 0 ; n < param.length; n++){
if (param[n].length > 0){vec3.push(parseFloat(param[n]))}}
verts.push(vec3);}
if ( t[i][0] == 'f'){
var param = t[i].substr(1,t[i].length -1 );param = param.split(' ');
for ( var n = 0 ; n < param.length; n++){
if (param[n].length > 0){indices.push(parseInt(param[n]))}}}}
self.OBJ = [verts,indices]
