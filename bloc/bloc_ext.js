/*
    All special blocks goes here....
    TODO : 
    // Add comm block, in block, out block
*/

function TryLoadExtensionBlock(originalblock)
{

    // @ equals
    switch ( originalblock.typename)
    {
        case "in": return new WarpInBlock(originalblock.typename, Editor.WindowExplorer.Thumbnails[0], originalblock.displayCanvas);
        case "out": return new WarpOutBlock(originalblock.typename, Editor.WindowExplorer.Thumbnails[0], originalblock.displayCanvas);
        case "inlet": return new InletBlock(originalblock.typename, Editor.WindowExplorer.Thumbnails[0], originalblock.displayCanvas);
        case "outlet": return new OutletBlock(originalblock.typename, Editor.WindowExplorer.Thumbnails[0], originalblock.displayCanvas);
        case "win": var b = new WindowBlock(originalblock.typename, Editor.WindowExplorer.Thumbnails[0], originalblock.displayCanvas); b.isVirtual = false; return b;
        case "virtual": var b = new WindowBlock(originalblock.typename, Editor.WindowExplorer.Thumbnails[0], originalblock.displayCanvas); b.isVirtual = true; return b;
        case "ditto": return new DittoBlock(originalblock.typename, Editor.WindowExplorer.Thumbnails[0], originalblock.displayCanvas);
        case "bang": return new Bang(originalblock.typename, Editor.WindowExplorer.Thumbnails[0], originalblock.displayCanvas);
        case "switch": return new SwitchBlock(originalblock.typename, Editor.WindowExplorer.Thumbnails[0], originalblock.displayCanvas);
        case "number": return new NumBlock(originalblock.typename, Editor.WindowExplorer.Thumbnails[0], originalblock.displayCanvas);
        case "slider": return new SliderBlock(originalblock.typename, Editor.WindowExplorer.Thumbnails[0], originalblock.displayCanvas);
        case "knob": return new KnobBlock(originalblock.typename, Editor.WindowExplorer.Thumbnails[0], originalblock.displayCanvas);
        case "tab": return new TabBlock(originalblock.typename, Editor.WindowExplorer.Thumbnails[0], originalblock.displayCanvas);
        case "graph": return new GraphBlock(originalblock.typename, Editor.WindowExplorer.Thumbnails[0], originalblock.displayCanvas);
        case "matrix": return new MatrixBlock(originalblock.typename, Editor.WindowExplorer.Thumbnails[0], originalblock.displayCanvas);
        case "comm":  return new CommBlock(originalblock.typename, Editor.WindowExplorer.Thumbnails[0], originalblock.displayCanvas);
        case "msg":  return new MessageBlock(originalblock.typename, Editor.WindowExplorer.Thumbnails[0], originalblock.displayCanvas);
        case "env~" : return new Linear4Graph(originalblock.typename,Editor.WindowExplorer.Thumbnails[0],originalblock.displayCanvas );
        case "linear~" : return new Linear4Graph(originalblock.typename,Editor.WindowExplorer.Thumbnails[0],originalblock.displayCanvas );
        case "faust~eqdemo" : return new EqualizerGraph(originalblock.typename,Editor.WindowExplorer.Thumbnails[0],originalblock.displayCanvas );
    }
    return null;
}


function DoesBlockHasWireOutToBlock(Block, srcBlock, portNumber)
{
    for ( var i = 0 ; i < Block.outputslots[portNumber].length; i++)
    {
        if ( Block.outputslots[portNumber][i].blocId == srcBlock.id )
            return true;
    }
    return false;
}
class InletBlock extends Block
{
    // @ When inlet index change. Inlet should be unwrap(delete all inputs), win blocks i/o should be recomputed and getwrapping() be recalled.
    // @ Should not draw input.
    // @ Should pass audio stream.
    OnCreate()
    {
        // @ Generated inputscript
        var genscript = new Array();
        genscript.push("# AutoGenerated Code for inlet");
        genscript.push("# @ Logic for [inlet] block");
        genscript.push("--decl");
        genscript.push("inp(1);outp(1)");
        genscript.push("memset(2)");
        genscript.push("self.audioNode = audioContext.createGain()");
        genscript.push("--code");
        genscript.push("out0(0)");
        genscript.push("--ipf1");
        genscript.push("self.OnMemoryChange()")
        genscript.push("--wi0");
        genscript.push("OnNodeConnect(wblock,self.audioNode);");
        genscript.push("--dcwi0");
        genscript.push("OnNodeDisconnect(wblock,self.audioNode);");
        this.NativeScript = genscript;
        this.SetMemorySize(2);
        
    }

    // @ This should be called after memory definition
    // @ This function connect inlet to anything [abstraction ] objects are connected to. it reload i/o of [abstraction ] objects.. 
    OnMemoryChange()
    {
        this.ClearInputPort(0);
        // Here we should call SearchWindowPorts from previous [win windows]
        for ( var i = 0 ; i < Editor.PatchInstances.length; i++)
        {
            if ( Editor.PatchInstances[i].memory[1] == this.Window)
                Editor.PatchInstances[i].SearchWindowPorts();
        }
        this.GetWrapping();
    }
    // @ Reset connection of object.
    ResetWrapping()
    {
        // Clear O connection.
        this.ClearOutputPort(0);
        // Get connection of corresponding patch instance
        this.GetWrapping();
    }
    // @ Add a new connection from all [abstraction ]object wires
    GetWrapping()
    {
       //console.log("wrapping inlet ");
        for ( var i = 0; i < Editor.PatchInstances.length; i++)
        {
            if ( Editor.PatchInstances[i].memory[1] != this.Window)
                continue;
            // Get all wireInfo of [win ] at slots memory
            for ( var n = 0; n < Editor.PatchInstances[i].inputslots[this.memory[1]].length; n++ )
            {
                // get source block
                // get source com 
                var source = GetBlockByID( Editor.PatchInstances[i].inputslots[this.memory[1]][n].blocId);
                var sourceCom = Editor.PatchInstances[i].inputslots[this.memory[1]][n].comPort;
                // connect source to this
                source.AddWireOut(sourceCom, this.id, 0 );
                // connect this to source at source com
                this.AddWireIn(0,source.id, sourceCom);
               // console.log("[virtual ]rewrapping and wiring inlet # " + this.memory[1] + " in " + this.Window );
            }
        }
    }
    
   
    // @ An OnDestroy function...
}
class OutletBlock extends Block
{
    // Do not draw input.
    OnCreate()
    {
       // @ Generated inputscript
        var genscript = new Array();
        genscript.push("# AutoGenerated Code for outlet");
        genscript.push("# @ Logic for [outlet] block");
        genscript.push("--decl");
        genscript.push("inp(1);outp(1)");
        genscript.push("memset(2)");
        genscript.push("self.audioNode =  audioContext.createGain()");
        genscript.push("--code");
        genscript.push("out0(0)");
        genscript.push("--ipf1");
        genscript.push("self.OnMemoryChange()")
        genscript.push("--wi0");
        genscript.push("OnNodeConnect(wblock,self.audioNode);");
        genscript.push("--dcwi0");
        genscript.push("OnNodeDisconnect(wblock,self.audioNode);");
        this.NativeScript = genscript;
        this.SetMemorySize(2);
       
        
    }
    // @ This should be called after memory definition
    // @ This function connect outlet to anything [abstraction ] objects are connected to. it reload i/o of [abstraction ] objects.. 
    OnMemoryChange()
    {
        // Clear O connection.
        this.ClearOutputPort(0);
        // Recompute port count of [abstraction ] objects. It is needed because memory has changed.
        for ( var i = 0 ; i < Editor.PatchInstances.length; i++)
        {
            if ( Editor.PatchInstances[i].memory[1] == this.Window)
                Editor.PatchInstances[i].SearchWindowPorts();
        }
        // Get connection of corresponding patch instance
        this.GetWrapping();
    }
    // @ Reset connection of object (without recalculing [abstraction ] io)
    ResetWrapping()
    {
        // Clear O connection.
        this.ClearOutputPort(0);
        // Get connection of corresponding patch instance
        this.GetWrapping();
    }
    // @ Add a new connection from all [abstraction ]object wires
    GetWrapping()
    {
        //console.log("wrapping outlet ");
        for ( var i = 0; i < Editor.PatchInstances.length; i++)
        {
            if ( Editor.PatchInstances[i].memory[1] != this.Window)
                continue;
            // Get all wireInfo of [win ] at slots memory
            for ( var n = 0; n < Editor.PatchInstances[i].outputslots[this.memory[1]].length; n++ )
            {
                // Get input block destination
                var source = GetBlockByID( Editor.PatchInstances[i].outputslots[this.memory[1]][n].blocId);
                // Get input port destination
                var sourceCom = Editor.PatchInstances[i].outputslots[this.memory[1]][n].comPort;
                // connect this outlet to destination
                this.AddWireOut(0,source.id, sourceCom);
                // connect destination to this
                source.AddWireIn(sourceCom, this.id, 0 );
                //console.log("[virtual ]rewrapping and wiring outlet # " + this.memory[1] + " in " + this.Window );
            }
        }
    }
}
// @@@@@@@@@@@@@@@@@@@@@@@@ IMPORTANT NOTE ABOUT DIFFERENCE OF [WIN ] AND [VIRTUAL ] BLOCK @@@@@@@@@@@@@@@@@@@@@ 
// @ Virtual Block.
// @ Create virtual instance of a window. 
// @ If [win ] refer to the main base window. [virtual ] create a deep copy of it. 
// @ It exactly work as [win object ] but has some difference...
// @ It create a whole instance of a self.basePatch. If there was one before : it destroy it.

class WindowBlock extends Block
{
    // @ When window index change. All inputs/outputs from it should be removed & rewrapped. 
    // @ There is a specific limitations here cause memory 1 should be only set while renaming.
    // @ This should be cleared from Patch Instances memory in Editor when destroyed.
    OnCreate()
    {
        //console.log("Creating window block")
        // @ Generated inputscript
        var genscript = new Array();
        genscript.push("# AutoGenerated Code for Windowing");
        genscript.push("# @ Logic for abstraction block");
        genscript.push("--decl");
        genscript.push("memset(2)");
        genscript.push("#df Abstraction of a patch space");
        this.NativeScript = genscript;
        // @ Register to Editor Patch Instances...
        Editor.PatchInstances.push(this);
        
    }
    OnChangeIdentity()
    {
        if ( this.isVirtual && this.deepCopySpace != null )
        {
            Editor.DestroyWindow(this.deepCopySpace);
        }
    }
    Destroy( updateList = true )
    {
        if ( this.isVirtual && this.deepCopySpace != null)
        {
            Editor.DestroyWindow(this.deepCopySpace);
        }
        var patchindex = Editor.PatchInstances.indexOf(this);
        if ( patchindex > -1 )
            Editor.PatchInstances.splice(patchindex, 1);
        
        // @ Clear ports
        var incount = this.inputslots.length;
        var outcount = this.outputslots.length;
        var i;
        for(i=incount-1;i>=0;i--)
            this.ClearInputPort(i);
        for(i=outcount-1;i>=0;i--)
            this.ClearOutputPort(i);
        
        // @ Try remove bloc from editor
        ide.TryCloseBlock(this)
        
        // @ Unset Interaction (we can only destroy while renaming so lets just do if renamed )
        UserIsTyping = false;
        
        if (!updateList)
            return;
        
        Blocks.splice(this.index,1);
        RecomputeMapIndex();
        
    }
 
    
    // @ OnMemoryChange is call at creation or when getting arguments...
    // @ >It destroy all its i/o
    // @ >Create space if needed. 
    // @ >Get new i/o count from new memory
    
    OnMemoryChange()
    {
        
        //console.log("[virtual] clearing abstraction IO");
        
        if ( this.prevmem == null )
            this.prevmem = this.memory[1];
        
        var i;
        // @ Create copy of i/o slots
        var cpyinputslots = new Array();
        for ( i =0; i< this.inputslots.length; i++ )
        {
            var slot = new Array();
            for ( var n =0; n< this.inputslots[i].length; n++ )
            {
                slot.push(new WireInData(this.inputslots[i][n].blocId,this.inputslots[i][n].comPort));
            }
            cpyinputslots.push(slot);
        }
        var cpyoutputslots = new Array();
        for ( i =0; i< this.outputslots.length; i++ )
        {
            var slot = new Array();
            for ( var n =0; n< this.outputslots[i].length; n++ )
            {
                slot.push(new WireOutData(this.outputslots[i][n].blocId,this.outputslots[i][n].comPort));
            }
            cpyoutputslots.push(slot);
        }
        
        // save current argument & unwire
        var tm = this.memory[1];
        this.memory[1] = this.prevmem;
        var incount = this.inputslots.length;
        var outcount = this.outputslots.length;
        for(i=incount-1;i>=0;i--)
            this.ClearInputPort(i);
        for(i=outcount-1;i>=0;i--)
            this.ClearOutputPort(i);
        this.memory[1] = tm;
        
        // Create deep copy
        if ( this.isVirtual)
        {
            // @ Destroy DeepCopy (deepCopyName)
            if ( this.deepCopySpace != null)
                Editor.DestroyWindow(this.deepCopySpace);
            
            //console.log("[virtual] creatng deep copy space");
            // @ deepCopyName=Create  DeepCopy (memory[1])
            this.deepCopySpace = CreateDeepCopyOfWindow(this.memory[1], this.displayCanvas);
            // memory[1] = deepCopyName
            this.memory[1] = this.deepCopySpace;
            //console.log("[virtual] space is " + this.memory[1] )
        }
        
        // Get Window Ports
        this.SearchWindowPorts();
        // Connect back.
        for ( i = 0 ; i < cpyinputslots.length; i++ )
        {
            if ( this.inputslots.length <= i )
            {
                //console.log("[virtual ] fewer inputs detected when renaming [abstraction ]")
                break;
            }
                
            for ( var n =0; n< cpyinputslots[i].length; n++ )
            {
                // Never use AddWireIn... Always use  Add Wire Out
                var b = GetBlockByID(cpyinputslots[i][n].blocId);
                if ( b != null)
                    b.AddWireOut(cpyinputslots[i][n].comPort, this.id, i);
                else 
                    console.log("[virtual] null error" )
                //this.AddWireIn(i, cpyinputslots[i][n].blocId, cpyinputslots[i][n].comPort);
            }
        }
        for ( i = 0 ; i < cpyoutputslots.length; i++ )
        {
            if ( this.outputslots.length <= i )
                break;
            
            for ( var n =0; n< cpyoutputslots[i].length; n++ )
            {
                this.AddWireOut(i, cpyoutputslots[i][n].blocId, cpyoutputslots[i][n].comPort);
            }
        }
        this.prevmem = this.memory[1];
    }
    
    // @ This function set I/O size depending of number of inlet/outlet of the specific window. 
    SearchWindowPorts()
    {
        var ios = GetWarpsCountOfWindow(this.memory[1]);
        if (this.inputslots.length != ios[0])
            this.SetInputCount(ios[0]); 
            
        if (this.outputslots.length != ios[1])
            this.SetOutputCount(ios[1]);
    }
    LoadMemoryFromArguments(s)
    {
        if ( s == null )
            return ;
        var sp = s.split(' ')
        var ctr = 0;
        for ( var i = 0 ; i < sp.length ; i++)
        {
            if ( this.memory.length <= ctr )
                break;

            if  ( sp[i].length > 0 )
            {
                if ( ctr > 0)
                {  
                    var value = TryParseLine(sp[i]);
                    this.memory[1] = value;
                    
                }
                ctr++;
            }
        }
        this.OnMemoryChange();
    }
    I(portnumber, data){}

    // @ Clean
    AddWireIn(PortNumber, destId, destCOM)
    {
        var sourcebloc = GetBlockByID(destId);
        if ( this.inputslots.length <= PortNumber)
        {
            //console.log("error detected when trying to connect abstractio at com#  " + PortNumber + " to " + sourcebloc.typename + " com# "+destCOM  );
            return;
        }
            
        // Let wiring to it.
        this.inputslots[PortNumber].push(new WireInData(destId, destCOM));
        // Warp to all inlet wire.
        var sourcebloc = GetBlockByID(destId);
        if ( sourcebloc == null )
            return;
        
        for ( var i = 0 ; i < Blocks.length; i++)
        {
            if ( Blocks[i].Window != this.memory[1])
                continue;
            if ( Blocks[i].typename.indexOf("inlet")==-1)
                continue;
                
            if (Blocks[i].memory[1] != PortNumber)
                continue;
            // Wrap wire IN
            //console.log("[virtual]connecting " + sourcebloc.typename + " to " + Blocks[i].typename + " from " +Blocks[i].Window );
            sourcebloc.AddWireOut(destCOM, Blocks[i].id,0);
        }
         
    }
    // @ Disconnect Object input. On the same time, unwrap to any corresponding inlet. This is clean.
    ClearInputPortWire(PortNumber, WireIndex)
    {
        // @ Clear all related outputslots
        // Source is object that is wired to [abstraction ]
        var source = GetBlockByID(this.inputslots[PortNumber][WireIndex].blocId);
         // sourcePortCOM is object that is wired to [abstraction ]
        var sourcePortCOM = this.inputslots[PortNumber][WireIndex].comPort;
        for ( var i = 0 ; i < Blocks.length; i++)
        {
            // Find [inlet ] that from this win that has PortNumner memory.
            if ( Blocks[i].Window != this.memory[1])
                continue;
            if ( Blocks[i].typename.indexOf("inlet")==-1)
                continue;
                
            if (Blocks[i].memory[1] != PortNumber)
                continue;
            
            if (source == null )
                continue;
            
            // Iterate through source port com
            for ( var n =source.outputslots[sourcePortCOM].length-1 ; n >= 0; n--)
            {
                // if source wire is connected to corresponding inlet
                if ( source.outputslots[sourcePortCOM][n].blocId == Blocks[i].id)
                {
                    //console.log("[virtual]disconnecting " + source.typename + " from " + Blocks[i].typename + " from " +Blocks[i].Window );
                    // Clear input port of inlet 
                    Blocks[i].ClearInputPortWire(0,source.outputslots[sourcePortCOM][n].comPort);
                    // Clear source output port 
                    source.ClearOutputPortWire(sourcePortCOM, n);
                }
            }
        }
        this.inputslots[PortNumber].splice(WireIndex,1);
    }
    // @ Clean
    AddWireOut(PortNumber, destId, destCOM) 
    {
       if ( this.outputslots.length <= PortNumber)
            return;
        
        this.outputslots[PortNumber].push(new WireOutData(destId, destCOM));
        var destbloc = GetBlockByID(destId);
        destbloc.AddWireIn(destCOM, this.id, PortNumber );
        for ( var i = 0 ; i < Blocks.length; i++)
        {
            if ( Blocks[i].Window != this.memory[1])
                continue;
            if ( Blocks[i].typename.indexOf("outlet")==-1)
                continue;
            if (Blocks[i].memory[1] != PortNumber)
                continue;
            // Wrap wire Out
            //console.log("[virtual] connecting " + destbloc.typename + " to " + Blocks[i].typename + " from " +Blocks[i].Window );
            Blocks[i].AddWireOut(0, destbloc.id, destCOM);
        }
         
    }
    ClearOutputPortWire(PortNumber, WireIndex)
    {
        // destination block [abstraction ] block is wired to.
        var dest = GetBlockByID(this.outputslots[PortNumber][WireIndex].blocId);
        // destination block com port [abstraction ] block is wired to.
        var destPortCOM = this.outputslots[PortNumber][WireIndex].comPort;

        for ( var i = 0 ; i < Blocks.length; i++)
        {
            // Find [outlet ] that from this win that has PortNumner memory.
            if ( Blocks[i].Window != this.memory[1])
                continue;
            if ( Blocks[i].typename.indexOf("outlet")==-1)
                continue;
                
            if (Blocks[i].memory[1] != PortNumber)
                continue;
            
            if (dest == null )
                continue;
            
            // Iterate through dest bloc inputslots
            for ( var n = dest.inputslots[destPortCOM].length-1 ; n >= 0; n--)
            {
                // If destination block is wired to corresponding outlet 
                if ( dest.inputslots[destPortCOM][n].blocId == Blocks[i].id)
                {
                    //console.log("[virtual] disconnecting " + dest.typename + " from " + Blocks[i].typename + " from " +Blocks[i].Window );
                    // Disconnect outlet 
                    Blocks[i].ClearOutputPortWire(0,dest.inputslots[destPortCOM][n].comPort);
                    // Disconnect destination block
                    dest.ClearInputPortWire(destPortCOM, n);
                   
                   
                }
            }
        }
                
        this.outputslots[PortNumber].splice(WireIndex,1);
    }
}

// @ The [ditto ] object 
// @ Create a multiple copies of an [abstraction ]. for example, [ditto osc 16] will create 16 instance
// @ Of patch osc. Ditto' abstractions do not output.
// @ Ditto do not redirect i/o of its abstraction and cannot pass audiostream. It can only pass values through core thread.

class DittoBlock extends Block
{
    OnCreate()
    {
         // @ Generated inputscript
        var genscript = new Array();
        genscript.push("# AutoGenerated Code for Cloning");
        genscript.push("# @ Logic for [DITTO %%] block");
        genscript.push("--decl")
        genscript.push("memset(3)")
        genscript.push("#df Multiple copies of an abstraction")
        this.NativeScript = genscript;
        this.CopySelected = -1;
    }
    OnChangeIdentity()
    {
        this.DestroyCopies();
    }
    Destroy( updateList = true )
    {
        this.DestroyCopies();
        // @ Clear ports
        var incount = this.inputslots.length;
        var outcount = this.outputslots.length;
        var i;
        for(i=incount-1;i>=0;i--)
            this.ClearInputPort(i);
        for(i=outcount-1;i>=0;i--)
            this.ClearOutputPort(i);
        
        // @ Try remove bloc from editor
        ide.TryCloseBlock(this)
        
        // @ Unset Interaction (we can only destroy while renaming so lets just do if renamed )
        UserIsTyping = false;
        
        if (!updateList)
            return;
        Blocks.splice(this.index,1);
        RecomputeMapIndex();
        
    }
    DestroyCopies()
    {
        if ( this.Copies != null )
        {
            for ( var i = 0 ; i < this.Copies.length ; i++)
                Editor.DestroyWindow(this.Copies[i]);
        }
        this.Copies = new Array();
        this.InletsCopies = new Array();
    }
    OnDefinitionChange()
    {

        //console.log("ditto onchange called " + this.memory[1] + " " + this.memory[2]);
        // @ Destroy Copies
        this.DestroyCopies();
        // @ Get number of inlet slots of desired win
        // Add one more slot for mentionning instance 
        
        var icount = GetInletCountOfWindow(this.memory[1]);
        if (this.inputslots.length != icount)
            this.SetInputCount(icount+1); 
        
       
        // @ Create Copies. & get inlets foreach copy in array.
        for ( var i = 0 ; i < this.memory[2]; i++ )
        {
            //console.log("[ditto ] Creating deep copy space of " + this.memory[1]);
            var spacename = CreateDeepCopyOfWindow(this.memory[1], this.displayCanvas);
            this.Copies.push(spacename);
            // Get inlets of
            var farInlets = GetInletsOfWindow(spacename);
            this.InletsCopies.push(farInlets); // there is one foreach copy 
            this.CopySelected = -1;
            
        }
    }
    LoadMemoryFromArguments(s)
    {
        if ( s == null )
            return ;
        var sp = s.split(' ')
        var ctr = 0;
        for ( var i = 0 ; i < sp.length ; i++)
        {
            if ( this.memory.length <= ctr )
                break;

            if  ( sp[i].length > 0 )
            {
                if ( ctr > 0)
                {  
                    var value = TryParseLine(sp[i]);
                    this.memory[ctr] = value;
                }
                ctr++;
            }
        }
        this.OnDefinitionChange();
    }
    I(portnumber, data)
    {
        // Set current Copy selected
        if ( portnumber == this.inputslots.length-1)
        {
            
            var v = parseInt(data);
            if ( v < this.Copies.length)
                this.CopySelected = data;
            else 
                this.CopySelected = -1;
            return;
        }
        //@ Bang corresponding inlet with data depending of copyIndex
        if ( this.CopySelected >= 0 )
        {
            for ( var n = 0 ; n < this.InletsCopies[this.CopySelected][portnumber].length; n++ )
            {
                  this.InletsCopies[this.CopySelected][portnumber][n].I(0,data);  
            }
            return;
        }
        else
        {
            for ( var c = 0 ; c < this.InletsCopies.length; c++ )
            {
                for ( var n = 0 ; n < this.InletsCopies[c][portnumber].length; n++ )
                {
                  this.InletsCopies[c][portnumber][n].I(0,data);  
                }
            }
            return;
        }
    }
}


// @ General information pass 
class WarpInBlock extends Block
{
    // @ Wrap to any out at creation
    OnCreate()
    {

            // @ Generated inputscript
            var genscript = new Array();
            genscript.push("# AutoGenerated Code for Warping");
            genscript.push("# @ Logic for [IN %%] block");
            genscript.push("--decl");
            genscript.push("inp(1)"); 
            genscript.push("outp(1)");
            genscript.push("memset(2)");
            genscript.push("self.audioNode =  audioContext.createGain()");
            genscript.push("--code");
            genscript.push("out0(0)");
            genscript.push("--ipf1");
            genscript.push("self.OnMemoryChange()");
            genscript.push("--wi0");
            genscript.push("OnNodeConnect(wblock,self.audioNode);");
            genscript.push("--dcwi0");
            genscript.push("OnNodeDisconnect(wblock,self.audioNode);");
            this.NativeScript = genscript;
            // Force compiling
        
            this.SetInputCount(1);
            this.SetOutputCount(1);
        
    }
    OnMemoryChange()
    {
        // @ Clear input port
        this.ClearInputPort(0);
        // @ Connect to all out mem
        for ( var i = 0 ; i < Blocks.length; i++)
        {
            if ( Blocks[i].typename.indexOf("out ") != 0 )
                continue;
            if ( Blocks[i].memory[1] != this.memory[1])
                continue;
            // Wire in 
            Blocks[i].AddWireOut(0,this.id,0);
        }
    }
    Draw()
    {
          // Compute Width and Port distance
        var w = this.typename.length * VisualParameters.BlockFontWidth; 
        if ( w < 25 )
        {
            w = 40 ;
        }
        var maxSlot = this.inputslots.length;
        if (  this.outputslots.length > maxSlot){
            maxSlot = this.outputslots.length;
        }
        
        var segwidth = w /maxSlot ;
        if ( segwidth < 10 * 1.5){
            // recompute w 
            segwidth = 10 * 1.5;
            w = maxSlot *segwidth;
        }
        
        this.bodyBox.w = w;
        this.bodyBox.h = 25;
        
        var iostartpos  = this.bodyBox.x + this.bodyBox.w/segwidth ; 
         
        // @ Draw Boxes
        this.DrawBody()
        
        // @ Draw IOs
        this.DrawO(iostartpos,segwidth,this.outputslots.length)
        
        // @ Print text
        var _g = this.displayCanvas.context;
        _g.fillStyle = VisualParameters.BlockStrokeColor;
        if (this.renaming)
        {
            _g.fillStyle = VisualParameters.BlockFillColor;
        }
        _g.font = VisualParameters.BlockFont;
        _g.fillText(this.typename,this.bodyBox.x,this.bodyBox.y+16 );
        
        // @ Draw Wires
        this.DrawWires();
    }
}
class WarpOutBlock extends Block
{
    OnCreate()
    {
       
            // @ Generated inputscript
            var genscript = new Array();
            genscript.push("# AutoGenerated Code for Warping");
            genscript.push("# @ Logic for [OUT %%] block");
            genscript.push("--decl");
            genscript.push("inp(1)"); 
            genscript.push("outp(1)");
            genscript.push("memset(2)");
            genscript.push("self.audioNode =  audioContext.createGain()");
            genscript.push("--code");
            genscript.push("out0(0)");
            genscript.push("--ipf1");
            genscript.push("self.OnMemoryChange()");
            genscript.push("--wi0");
            genscript.push("OnNodeConnect(wblock,self.audioNode);");
            genscript.push("--dcwi0");
            genscript.push("OnNodeDisconnect(wblock,self.audioNode);");
            this.NativeScript = genscript;
            // Force compiling
        
            this.SetInputCount(1);
            this.SetOutputCount(1);
    }
    OnMemoryChange()
    {
        // @ Clear input port
        this.ClearOutputPort(0);
        // @ Connect to all out mem
        var ctr = 0;
        for ( var i = 0 ; i < Blocks.length; i++)
        {
            if ( Blocks[i].typename.indexOf("in ") != 0 )
                continue;
            if ( Blocks[i].memory[1] != this.memory[1])
                continue;
            // Wire in 
            this.AddWireOut(0,Blocks[i].id,0);
            ctr++;
        }
        if ( ctr != 0)
            return;
        
        // create in block...
        Editor.AddNewWindow(Editor.GetEmptyWindow());
        var inbloc = CreateSpecificBlock("in "+this.memory[1], this.displayCanvas.box.w/2,this.displayCanvas.box.h/2 );
    }
    Interact()
    {
        // On click extends to inblock 0
        if (  IsMouseInsideBox(this.bodyBox,this.displayCanvas) 
            && mousepressed && (ctrlPressed||Editor.inPlayMode)
            && !UserIsGrabbing && !UserIsTyping && !UserIsWiring)
        {
            var typename = this.memory[1];
            var b = GetBlockByTypeName("in " +typename);
            if ( b != null)
                Editor.AddNewWindow(b.Window);
            return ;
        }
        this.DefaultInteract();
    }
    Draw()
    {
          // Compute Width and Port distance
        var w = this.typename.length * VisualParameters.BlockFontWidth; 
        if ( w < 25 )
        {
            w = 40 ;
        }
        var maxSlot = this.inputslots.length;
        if (  this.outputslots.length > maxSlot){
            maxSlot = this.outputslots.length;
        }
        
        var segwidth = w /maxSlot ;
        if ( segwidth < 10 * 1.5){
            // recompute w 
            segwidth = 10 * 1.5;
            w = maxSlot *segwidth;
        }
        
        this.bodyBox.w = w;
        this.bodyBox.h = 25;
        
        var iostartpos  = this.bodyBox.x + this.bodyBox.w/segwidth ; 
         
        // @ Draw Boxes
        this.DrawBody()
        
        // @ Draw IOs
        this.DrawI(iostartpos,segwidth,this.inputslots.length)
        //this.DrawIOs(iostartpos,segwidth,this.inputslots.length, this.outputslots.length )
        
        // @ Print text
        var _g = this.displayCanvas.context;
        _g.fillStyle = VisualParameters.BlockStrokeColor;
        if (this.renaming)
        {
            _g.fillStyle = VisualParameters.BlockFillColor;
        }
        _g.font = VisualParameters.BlockFont;
        _g.fillText(this.typename,this.bodyBox.x,this.bodyBox.y+16 );
        
    }
}


class CommBlock    extends Block
{
    Draw()
    {
        var w = this.memory[1].toString().length * 7 + 7; // we could mesure text... here 
        if ( w < 25 )
        {
             w = 40 ;
        }
        this.bodyBox.w = w;
        this.bodyBox.h = 25;
        var _g = this.displayCanvas.context;
        // Draw Body
        _g.fillStyle = VisualParameters.BlockStrokeColor;
        if ( this.renaming)
            _g.fillStyle = VisualParameters.BlockHighLightColor;
        _g.fillRect(this.bodyBox.x,this.bodyBox.y,this.bodyBox.w,this.bodyBox.h);
        // Draw custom appearance
        _g.fillStyle = VisualParameters.BlockFillColor;
        _g.font = "Bold 12px Courier";
        _g.fillText(this.memory[1].toString(),this.bodyBox.x + 5,this.bodyBox.y+16 );
    }
    ProccessRenaming(e)
    {
        
        if ( e.keyCode == 46 ) //@ key suppr was pressed  
        {
            this.Destroy();
            UserIsTyping = false;
            return; 
        }
        
       if ( e.keyCode == 13 ) // @ key enter was pressed 
        {
           
            this.renaming = false;
            UserIsTyping = false;
            return;
        }
        if (  e.keyCode == 8 )
            this.memory[1] = this.memory[1].substr(0,this.memory[1].length-1);
        else
        {
            if ( !KeyIsIllegal(e.key))
            {
                this.memory[1] += e.key;
            }
             
        }
        return;
        
    }
    TryInteract()
    {
        var i; 
        if (!IsMouseInsideBox(this.bodyBox,this.displayCanvas))
            return;
        
        if ( Editor.hasdoubleclicked == true && !UserIsTyping)
        {
            // @ Destroy grabbed data... it can leave on the block
            this.grabbed = false;
            UserIsGrabbing = false;
            this.renaming = true;
            UserIsTyping = true;
            return;
        }
        
        // @ Do Grabbing
        this.GrabOrigin = new Vector2(mouseX-this.bodyBox.x, mouseY - this.bodyBox.y);
        this.grabbed = true;
        UserIsGrabbing = true;
    }
    Interact(){this.DefaultInteract();}
}

class MatrixBlock extends Block
{
    Draw()
    {
        if ( this.renaming || this.xSize == null || this.ySize == null)
        {
            this.DefaultDraw();
            return;
        }
        
        // set up 25 pixel per tab elements.
        var microboxinterval = 10;
        var microboxheight = 20;
        var microboxwidth  = 40;
        var totalw = this.xSize * (microboxwidth + microboxinterval);
        var totalh = this.ySize * (microboxheight + microboxinterval);
        
        this.bodyBox.w = totalw;
        this.bodyBox.h = totalh;
        
        this.DrawBody()
        
        // Draw each slot and there values. And draw IOSLOTS;
       
        // first input is reserved for flushing matrix.
        // input.
        var _g = this.displayCanvas.context;
        _g.strokeStyle = 'rgb(0,0,0)'
        
        _g.lineWidth = 3;
        var py = microboxinterval /2;
        var ctr = 1;
        //var inputsize = 5;
        
        // Draw first input box.
        var segwidth = 10 * 1.5;
        var iostartpos  = this.bodyBox.x + this.bodyBox.w/segwidth ;
        this.DrawI(iostartpos, segwidth, 1);
        _g.font = "Bold 18px Courier";
        for ( var y = 0 ; y < this.ySize; y++)
        {
            var px = microboxinterval /2;;
            
            for ( var x = 0 ; x < this.xSize ; x++)
            {
                _g.strokeRect(this.bodyBox.x+px,this.bodyBox.y+py, microboxwidth, microboxheight);
                
                // set up inputslots.
                this.inputsboxes[ctr] = new Box(this.bodyBox.x+px,this.bodyBox.y+py - microboxinterval, 10,10);
                // Draw the box
                _g.fillStyle = 'rgb(0,0,0)'
                if ( IsMouseInsideBox(this.inputsboxes[ctr], this.displayCanvas))
                    _g.fillStyle = 'rgb(0,0,255)'
                _g.fillRect(this.inputsboxes[ctr].x, this.inputsboxes[ctr].y, this.inputsboxes[ctr].w, this.inputsboxes[ctr].h);
                // draw matrix value 
                
                var s = this.memory[ctr].toString();
                if ( s.length > 4 )
                    s = s.substr(0,4) + "..."
                _g.fillText(s,this.bodyBox.x + px + 3,this.bodyBox.y + py + 13  );
                px += microboxwidth + microboxinterval;
                ctr++;
            }
            py += microboxheight + microboxinterval;
            
        }
        // Draw outputslot.
        this.DrawO(iostartpos, segwidth, 1);
        // Then draw wire.
        this.DrawWires();
        
    }
}

class MessageBlock extends Block
{
    Draw() 
    {
     
        var w = this.memory[1].toString().length * 12; // we could mesure text... here 
        if ( w < 25 )
        {
             w = 40 ;
        }
        this.bodyBox.w = w;
        this.bodyBox.h = 25;
        // Draw Body
        this.DrawBody()
        // Draw In and Out
        this.DrawI(this.bodyBox.x + this.bodyBox.w/2,0,1)
        this.DrawO(this.bodyBox.x + this.bodyBox.w/2,0,1)
         var _g = this.displayCanvas.context;
        // Draw custom appearance
         _g.fillStyle = 'rgb(0,0,0)';
        _g.font = "16px Autopia";
        _g.fillText(this.memory[1].toString(),this.bodyBox.x + 5,this.bodyBox.y+16 );
        
         // @ Draw Wires
        this.DrawWires();
    }
    DrawBody()
    {
        var _g = this.displayCanvas.context;
        // @ Draw Box
        // Plain color
        _g.fillStyle = VisualParameters.BlockFillColor;
        if (this.renaming)
        {
            _g.fillStyle = VisualParameters.BlockHighLightColor;
        }
        _g.fillRect(this.bodyBox.x,this.bodyBox.y,this.bodyBox.w,this.bodyBox.h);
        
        // Outline
        _g.lineWidth = VisualParameters.BlockBorderWidth;
        _g.strokeStyle = VisualParameters.BlockStrokeColor;
        if (this.renaming )
        {
            _g.strokeStyle = VisualParameters.BlockFillColor;
        }
        if (IsMouseInsideBox(this.bodyBox,this.displayCanvas) || this.CurrentlyInteract() )
        {
            _g.strokeStyle = VisualParameters.BlockHighLightColor;
            Editor.Info = GetDocOfNativeScriptFromToken(this.NativeScript, "#df");
        }
        // if this is in library 
        // stroke special rect 
          var peaksize = 10;
         var color = VisualParameters.BlockStrokeColor;
         var linew = VisualParameters.BlockBorderWidth;
         this.displayCanvas.DrawLine(this.bodyBox.x + this.bodyBox.w , this.bodyBox.y,this.bodyBox.x, this.bodyBox.y, color, linew);
         this.displayCanvas.DrawLine(this.bodyBox.x, this.bodyBox.y , this.bodyBox.x, this.bodyBox.y+this.bodyBox.h ,color, linew);
         this.displayCanvas.DrawLine(this.bodyBox.x, this.bodyBox.y+this.bodyBox.h , this.bodyBox.x+this.bodyBox.w, this.bodyBox.y+this.bodyBox.h,color, linew);
        
         this.displayCanvas.DrawLine(this.bodyBox.x + this.bodyBox.w , this.bodyBox.y , this.bodyBox.x+this.bodyBox.w-peaksize, this.bodyBox.y+this.bodyBox.h/2,color, linew);
         this.displayCanvas.DrawLine(this.bodyBox.x+this.bodyBox.w-peaksize, this.bodyBox.y+this.bodyBox.h/2,this.bodyBox.x + this.bodyBox.w, this.bodyBox.y+this.bodyBox.h,color, linew);
        
    }
    ProccessRenaming(e)
    {
        
        if ( e.keyCode == 46 ) //@ key suppr was pressed  
        {
            this.Destroy();
            UserIsTyping = false;
            return; 
        }
        
       if ( e.keyCode == 13 ) // @ key enter was pressed 
        {
           
            this.renaming = false;
            UserIsTyping = false;
            return;
        }
        if (  e.keyCode == 8 )
            this.memory[1] = this.memory[1].substr(0,this.memory[1].length-1);
        else
        {
            if ( !KeyIsIllegal(e.key))
            {
                this.memory[1] += e.key;
            }
             
        }
        return;
        
    }
    TryInteract()
    {
        var i; 
        for (i = 0 ; i < this.inputsboxes.length; i++)
        {
            if (IsMouseInsideBox(this.inputsboxes[i], this.displayCanvas))
            {
                 if ( Editor.hasdoubleclicked )
                 {
                    this.grabbed = false; 
                    UserIsGrabbing = false;
                    this.ClearInputPort(i);
                    return;
                 }
                 this.wiringData = new WiringInfo(this.id, i, true);
                 UserIsWiring = true;
                 return;
            }
        }
        for (i = 0 ; i < this.outputsboxes.length; i++)
        {
            if (IsMouseInsideBox(this.outputsboxes[i],this.displayCanvas))
            {
                if ( Editor.hasdoubleclicked )
                {
                    this.grabbed = false;  
                    UserIsGrabbing = false;
                    this.ClearOutputPort(i);
                    return;
                }
                this.wiringData = new WiringInfo(this.id, i, false);
                UserIsWiring = true;
                return;
            }
        }      
    
        if (!IsMouseInsideBox(this.bodyBox,this.displayCanvas))
            return;
        
        // @ Update Code Editor 
        ide.TryLoadBlock(this)
        
        if ( Editor.hasdoubleclicked == true && !UserIsTyping)
        {
            // @ Destroy grabbed data... it can leave on the block
            this.grabbed = false;
            UserIsGrabbing = false;
            this.renaming = true;
            UserIsTyping = true;
            return;
        }
        
        // @ Do Grabbing
        this.GrabOrigin = new Vector2(mouseX-this.bodyBox.x, mouseY - this.bodyBox.y);
        this.grabbed = true;
        UserIsGrabbing = true;
    }
    Interact()
    {
        // @ Default interaction if typing but prob useless
        if ( this.renaming)
        {
            this.DefaultInteract();
            return;
        }
        if ( this.waspressed == 'undefined')
        {
            this.waspressed = false;
        }
        if ( !this.waspressed && IsMouseInsideBox(this.bodyBox,this.displayCanvas) 
            && mousepressed && (ctrlPressed||Editor.inPlayMode)
            && !UserIsGrabbing && !UserIsTyping && !UserIsWiring)
        {
            this.OIO();
            this.waspressed = true;
            return ;
        }
        if ( this.waspressed && !mousepressed && (ctrlPressed||Editor.inPlayMode) )
        {
            this.waspressed = false;  return;

        }
        this.DefaultInteract();
    }
} 
class SwitchBlock extends Block
{
    Draw() 
    {
        // @ Default draw if typing...
        if ( this.renaming)
        {
            this.DefaultDraw();
            return;
        }
        // @ Display Bang graphics 
        var _g = this.displayCanvas.context;
        
        this.bodyBox.w = 20;
        this.bodyBox.h = 20;
        // Draw Body
        this.DrawBody()
        // Draw In and Out
        this.DrawI(this.bodyBox.x + this.bodyBox.w/2,0,1)
        this.DrawO(this.bodyBox.x + this.bodyBox.w/2,0,1)
        
        // Draw custom appearance
        //@ Draw Cross 
        if ( this.memory[1] > 0)
        {
            _g.strokeStyle = "rgba(0,0,0)"; 
            _g.lineWidth = 3;

            // First line 
            _g.beginPath();
            _g.moveTo(this.bodyBox.x, this.bodyBox.y);
            _g.lineTo(this.bodyBox.x+this.bodyBox.w, this.bodyBox.y+this.bodyBox.h);
            _g.closePath();
            _g.stroke();
            // sec line 
            _g.beginPath();
            _g.moveTo(this.bodyBox.x, this.bodyBox.y+this.bodyBox.h);
            _g.lineTo(this.bodyBox.x+this.bodyBox.w, this.bodyBox.y);
            _g.closePath();
            _g.stroke();
        }
        
        // @ Draw Wires
        this.DrawWires();
        
    }
    Interact()
    {
        if ( this.renaming)
        {
            this.DefaultInteract();
            return;
        }
        if ( this.waspressed == 'undefined')
        {
            this.waspressed = false;
        }
        if ( !this.waspressed && IsMouseInsideBox(this.bodyBox,this.displayCanvas) && mousepressed && (ctrlPressed||Editor.inPlayMode)
           && !UserIsGrabbing && !UserIsTyping && !UserIsWiring)
        {
            this.waspressed = true;
            if ( this.memory[1] > 0 )
                this.memory[1] = 0;
            else
                this.memory[1] = 1;

            return;
        }
        if ( this.waspressed && !mousepressed && (ctrlPressed||Editor.inPlayMode) )
        {
            this.waspressed = false; return;

        } 
        this.DefaultInteract();
    }
}
class NumBlock extends Block
{
    Draw() 
    {
        if ( this.renaming)
        {
            this.DefaultDraw();
            return;
        }
        var w = this.memory[0].toString().length * 12;
        if ( w < 25 )
        {
             w = 40 ;
        }
        this.bodyBox.w = w;
        this.bodyBox.h = 25;
        // Draw Body
        this.DrawBody()
        // Draw In and Out
        this.DrawI(this.bodyBox.x + this.bodyBox.w/2,0,1)
        this.DrawO(this.bodyBox.x + this.bodyBox.w/2,0,1)
         var _g = this.displayCanvas.context;
        // Draw custom appearance
         _g.fillStyle = 'rgb(0,0,0)';
        _g.font = "16px Autopia";
        _g.fillText(this.memory[0].toString(),this.bodyBox.x + 5,this.bodyBox.y+16 );
        
         // @ Draw Wires
        this.DrawWires();
    }
    Interact()
    {
        // @ Default interaction if typing but prob useless
        if ( this.renaming)
        {
            this.DefaultInteract();
            return;
        }
        if ( IsMouseInsideBox(this.bodyBox,this.displayCanvas) && mousepressed && (ctrlPressed||Editor.inPlayMode)
           && !UserIsGrabbing && !UserIsTyping && !UserIsWiring)
        {
            this.waspressed = true;
            UserIsGrabbing = true;
        }
        if ( this.waspressed == true)
        {
            if (mousepressed && (ctrlPressed||Editor.inPlayMode) )
            {
                // Get MouseY distance from bodyboxY
                var val = (mouseY - this.displayCanvas.box.y) - this.bodyBox.y; 
                val = Math.floor(val/2);
                this.memory[0] = this.tempmemvalue - val;
                // Get Mouse relative to 
                this.OIO();
                return;
            }
            UserIsGrabbing = false;
            this.waspressed = false;
        }
        // @ Save a temp memory 
        this.tempmemvalue = this.memory[0];
        this.DefaultInteract();
    }
} 
class SliderBlock extends Block
{
    Draw() 
    {

        // @ Default draw if typing...
        if ( this.renaming)
        {
            this.DefaultDraw();
            return;
        }
        // @ Display Bang graphics 
        var _g = this.displayCanvas.context;
        this.bodyBox.w = 20;
        this.bodyBox.h = 100;
        // Draw Body
        this.DrawBody()
        // Draw In and Out
        this.DrawI(this.bodyBox.x + this.bodyBox.w/2,0,1)
        this.DrawO(this.bodyBox.x + this.bodyBox.w/2,0,1)
        
        // Draw custom appearance
        var min = this.memory[1]; 
        var max = this.memory[2];
        var sliderpos = (this.memory[0]-this.memory[1]) / (this.memory[2]-this.memory[1]);
        _g.fillStyle = 'rgb(0,0,255)';
        _g.fillRect(this.bodyBox.x,this.bodyBox.y+sliderpos*this.bodyBox.h,this.bodyBox.w,this.bodyBox.h/16);
        
        // @ Draw Wires
        this.DrawWires();
        
    }
    Interact()
    {
        // @ Default interaction if typing but prob useless
        if ( this.renaming)
        {
            this.DefaultInteract();
            return;
        }
        
         if ( IsMouseInsideBox(this.bodyBox,this.displayCanvas) && mousepressed && (ctrlPressed||Editor.inPlayMode)
           && !UserIsGrabbing && !UserIsTyping && !UserIsWiring)
         {
             this.waspressed = true;
             UserIsGrabbing = true;
             return;
         }
        if ( this.waspressed)
        {
             if (mousepressed && (ctrlPressed||Editor.inPlayMode) )
             {
                // Redraw slider at pos. Then recompute Mem(0)
                var _g = this.displayCanvas.context;
                var h = 100; // can be in param
                this.memory[0] = ((mouseY-this.displayCanvas.box.y - this.bodyBox.y) /  h) * (this.memory[2]-this.memory[1]) + this.memory[1];
                // bang ! 
                this.OIO();
                return; 
             }
             UserIsGrabbing = false;
             this.waspressed = false;
        }
        this.DefaultInteract();
    }
}  
class KnobBlock extends Block
{
    Draw() 
    {
        // @ Default draw if typing...
        if ( this.renaming)
        {
            this.DefaultDraw();
            return;
        }
        // @ Display Bang graphics 
        var _g = this.displayCanvas.context;
        this.bodyBox.w = 60;
        this.bodyBox.h = 60;
        
        // Draw Body
        var centerX = this.bodyBox.x + this.bodyBox.w / 2;
        var centerY = this.bodyBox.y + this.bodyBox.h / 2;
        _g.beginPath();
        _g.arc(centerX, centerY, this.bodyBox.w/2, 0, 2* Math.PI, false);
        _g.fillStyle =  'rgb(255,255,255)';
        _g.fill();
        _g.lineWidth = 3;
        _g.strokeStyle = 'rgb(0,0,0)';
        if (IsMouseInsideBox(this.bodyBox,this.displayCanvas) || this.CurrentlyInteract() )
        {
            _g.strokeStyle = 'rgb(0,0,255)';
        }
        _g.stroke();
        _g.closePath();
        
        // Draw In and Out
        this.DrawI(this.bodyBox.x + this.bodyBox.w/2,0,1)
        this.DrawO(this.bodyBox.x + this.bodyBox.w/2,0,1)
        
        // Draw knob bar
         // @ get angle
         var angle = ((this.memory[0]-this.memory[1]) / (this.memory[2]-this.memory[1])) * 360; 
         angle += 90; 
         _g.strokeStyle = "rgba(0,0,0)"; 
         _g.lineWidth = 5;
         _g.beginPath();
         _g.moveTo( centerX ,centerY);
          var aX = centerX + (this.bodyBox.w/2 * Math.cos(degrees_to_radians(angle)));  
          var aY = centerY + (this.bodyBox.w/2 * Math.sin(degrees_to_radians(angle)));
         _g.lineTo(aX,aY);
         _g.closePath();
         _g.stroke();
    
        
        // @ Draw Wires
        this.DrawWires();
        
    }
    Interact()
    {
        // @ Default interaction if typing but prob useless
        if ( this.renaming)
        {
            this.DefaultInteract();
            return;
        }
        if ( IsMouseInsideBox(this.bodyBox,this.displayCanvas) && mousepressed && (ctrlPressed||Editor.inPlayMode)
           && !UserIsGrabbing && !UserIsTyping && !UserIsWiring)
         {
             this.waspressed = true;
             UserIsGrabbing = true;
             return;
         }
        
         if ( this.waspressed)
         {
            // Redraw slider at pos. Then recompute Mem(0)
            if (mousepressed && (ctrlPressed||Editor.inPlayMode) )
            {
                var _g = this.displayCanvas.context;
                
                var centerX = this.bodyBox.x + this.bodyBox.w / 2;
                var centerY = this.bodyBox.y + this.bodyBox.h / 2;
                var angle = getAngle(mouseX-this.displayCanvas.box.x, mouseY-this.displayCanvas.box.y, centerX,centerY );
                angle = 360 - (angle);

                var adjustedAngle = angle- 90;
                if ( adjustedAngle <= 0 )
                    adjustedAngle = 270 + (90+adjustedAngle);

                // @ set memory 0 to 
                this.memory[0] = (adjustedAngle / 360) * (this.memory[2]-this.memory[1])+ this.memory[1];

                // Call IOI
                this.OIO();
                return;
            }
            UserIsGrabbing = false;
            this.waspressed = false;
        }
        this.DefaultInteract();
    }
} 
class TabBlock extends Block
{
    Draw()
    {
        // @ Default draw if typing...
        if ( this.renaming)
        {
            this.DefaultDraw();
            return;
        }
        var _g = this.displayCanvas.context;
        this.bodyBox.w = 100;
        this.bodyBox.h = 100;
        // Draw Body
        this.DrawBody()
        
        // Draw pixel values
        var pixsize = this.bodyBox.w / this.memory[3].length;
        // set pixel color
        _g.fillStyle = 'rgb(0,0,255)';
        var i;
        for (i = 0 ; i < this.memory[3].length; i++ )
        {
            // draw pix as color
            var p = this.memory[3][i];
            _g.fillRect(this.bodyBox.x+(i*pixsize),this.bodyBox.y+p,pixsize,pixsize);
        }
        // Draw IO
        var segwidth = this.bodyBox.w / 3 ; // width divide by maxslot which is 3  
        var iostartpos  = this.bodyBox.x +this.bodyBox.w/segwidth ;
        this.DrawI(iostartpos,segwidth,this.inputslots.length);
        this.DrawO(iostartpos,segwidth,this.outputslots.length);
        
         // @ Draw Wires
        this.DrawWires();
    }
    Interact()
    {
        // @ Default interaction if typing but prob useless
        if ( this.renaming)
        {
            this.DefaultInteract();
            return;
        }
        if ( IsMouseInsideBox(this.bodyBox,this.displayCanvas) && mousepressed && (ctrlPressed||Editor.inPlayMode)
           && !UserIsGrabbing && !UserIsTyping && !UserIsWiring)
        {
           var val = mouseY - this.displayCanvas.box.y - this.bodyBox.y;
           var index = Math.round((mouseX - this.displayCanvas.box.x - this.bodyBox.x) / 100 * 50);
           this.memory[3][index] = val; return;
        }
        this.DefaultInteract();
    }
}
class GraphBlock extends Block
{
    Draw()
    {
        if ( this.renaming)
        {
            this.DefaultDraw();
            return;
        }
        // @ Display Graph graphics 
        var _g = this.displayCanvas.context;
        this.bodyBox.w = 100;
        this.bodyBox.h = 100;
        // Draw Body
        this.DrawBody()
        // Draw pix values 
        var pixsize = this.bodyBox.w /this.memory[5].length;
        // set pixel color
        _g.fillStyle = 'rgb(0,0,255)';
        var i;
        for (i = 0 ; i <this.memory[5].length; i++ )
        {
            // draw pix as color
            var n;
            for (n = 0; n < this.memory[5][i].length; n++)
            {
                if ( this.memory[5][i][n] > 0 )
                {
                    _g.fillRect(this.bodyBox.x+(i*pixsize),this.bodyBox.y+(n*pixsize),pixsize,pixsize);
                }
            }

        }
        var segwidth = this.bodyBox.w / 5 ;   
        var iostartpos  = this.bodyBox.x +this.bodyBox.w/segwidth ;
        this.DrawI(iostartpos,segwidth,this.inputslots.length);
        this.DrawO(iostartpos,segwidth,this.outputslots.length);
          // @ Draw Wires
        this.DrawWires();
    }
    Interact()
    {
        // @ Default interaction if typing but prob useless
        if ( this.renaming)
        {
            this.DefaultInteract();
            return;
        }
        if ( IsMouseInsideBox(this.bodyBox,this.displayCanvas) && mousepressed && (ctrlPressed||Editor.inPlayMode)
           && !UserIsGrabbing && !UserIsTyping && !UserIsWiring)
        {
            var x = Math.round((mouseX - this.displayCanvas.box.x - this.bodyBox.x) / 100 * 50);
            var y = Math.round((mouseY - this.displayCanvas.box.y - this.bodyBox.y) / 100 * 50);
            this.memory[5][x][y] = 1;
            return;
        }
        this.DefaultInteract();
    }
}
// @ A 20-band equalizer. 
class EqualizerGraph extends Block
{
    Draw()
    {
        if ( this.renaming)
        {
            this.DefaultDraw();
            return;
        }
        var _g = this.displayCanvas.context;
        this.bodyBox.w = 400; // 20 pixels per band
        this.bodyBox.h = 50;
        this.DrawBody();
        var px = 0;
        for (var i =1 ; i < 21; i++)
        {
            // from -80 to 20 decibel we said...
            var v = (this.memory[i] + 80) / 100;
            _g.fillStyle = 'rgb(0,0,255)';
            _g.fillRect(this.bodyBox.x+px,this.bodyBox.y + this.bodyBox.h - v*this.bodyBox.h  , 20, v*this.bodyBox.h);
            _g.strokeStyle = 'rgb(255,255,255)';
            _g.lineWidth = 2;
            _g.strokeRect(this.bodyBox.x+px,this.bodyBox.y + this.bodyBox.h - v*this.bodyBox.h  , 20, v*this.bodyBox.h)
            px += this.bodyBox.w / 20;
        }
        var maxSlot = this.inputslots.length;
        if (  this.outputslots.length > maxSlot){
            maxSlot = this.outputslots.length;
        }
        var segwidth = this.bodyBox.w /maxSlot ;
        if ( segwidth < 10 * 1.5){
            // recompute w 
            segwidth = 10 * 1.5;
            this.bodyBox.w = maxSlot *segwidth;
        }
        _g.strokeStyle = 'rgb(0,0,0)';
        _g.lineWidth = 3;
        _g.strokeRect(this.bodyBox.x,this.bodyBox.y, this.bodyBox.w,this.bodyBox.h) 
        var iostartpos  = this.bodyBox.x  ;
        this.DrawI(iostartpos,segwidth,this.inputslots.length);
        this.DrawO(iostartpos,segwidth,this.outputslots.length);
          // @ Draw Wires
        this.DrawWires();
    }
    Interact()
    {
        if ( this.renaming)
        {
            this.DefaultInteract();
            return;
        }
        if ( mousepressed)
        {
            if (IsMouseInsideBox(this.bodyBox,this.displayCanvas) && (ctrlPressed||Editor.inPlayMode)
            && !UserIsGrabbing && !UserIsTyping && !UserIsWiring )
            {
                this.used = true;
                UserIsGrabbing = true;
            }
        }
        else
        {
            if ( this.used)
            {
                UserIsGrabbing = false;
                this.used = false;
            }
        }
        if (this.used == true)
        {
            var px = (mouseX- this.displayCanvas.box.x - this.bodyBox.x)/20 + 1;
            var py = mouseY- this.displayCanvas.box.y - this.bodyBox.y;
            py /= this.bodyBox.h;
            py *= 100;
            py = 100-py-80;
            this.memory[Math.round(px)] = py;
            this.OIO();
            return;
        }
        this.DefaultInteract();
    }
}
// Replica of wavestation enveloppe...
// In which there is 4 point (Attack, Reduction, Sustain, Release)
// All of those  point vary between 0-1 and each point can long a specific amount of time (attack 1 s) . 
// (release is lot longer than attack...)
class Linear4Graph extends Block
{
    Draw()
    {
        // 
        if ( this.renaming)
        {
            this.DefaultDraw();
            return;
        }
        var _g = this.displayCanvas.context;
        this.bodyBox.w = 100; // 50 pixel per points...
        this.bodyBox.h = 50;
        // Draw Body (do not print first ADSR Point space so reduce by 200/)
        this.DrawBody();
        // There is 4 points that can be dragged each up to 50 pixel from previous point X-position.
        // Those points values varies between 0-100% of 200pix. and have a length between 0-100% of 50 pixels
        // Create those 4 points if needed. There will x will be their time, y their value
        if ( this.ADSRPoints == null )
        {
            this.ADSRPoints = new Array();
            this.ADSRPoints.push(new Vector2(0,1)); // @DEF
            this.ADSRPoints.push(new Vector2(1,1)); // @A
            this.ADSRPoints.push(new Vector2(1,0)); // @D
            this.ADSRPoints.push(new Vector2(1,1)); // @S
            this.ADSRPoints.push(new Vector2(1,0)); // @R
        }
        var px = 0;
        _g.fillStyle = 'rgb(0,0,0)';
        _g.lineWidth = 2;
        _g.beginPath();
        _g.moveTo(this.bodyBox.x, this.bodyBox.y + this.bodyBox.h)
        for ( var i = 0; i < this.ADSRPoints.length; i++ ) 
        {
            px += this.ADSRPoints[i].x * (this.bodyBox.w/(this.ADSRPoints.length-1));
            var x = this.bodyBox.x+px;
            var y = this.bodyBox.y+((1-this.ADSRPoints[i].y) * this.bodyBox.h)
            // Just draw a rect
            _g.fillRect(x-3,y-3, 6, 6);
            _g.lineTo(x,y);
      
        }
        _g.stroke();
        var maxSlot = this.inputslots.length;
        if (  this.outputslots.length > maxSlot){
            maxSlot = this.outputslots.length;
        }
        var segwidth = this.bodyBox.w /maxSlot ;
        if ( segwidth < 10 * 1.5){
            // recompute w 
            segwidth = 10 * 1.5;
            this.bodyBox.w = maxSlot *segwidth;
        }
        
        var iostartpos  = this.bodyBox.x +this.bodyBox.w/segwidth ;
        this.DrawI(iostartpos,segwidth,this.inputslots.length);
        this.DrawO(iostartpos,segwidth,this.outputslots.length);
          // @ Draw Wires
        this.DrawWires();
        
    }
    Interact()
    {
        // @ Default interaction if typing but prob useless
        if ( this.renaming)
        {
            this.DefaultInteract();
            return;
        }
        if ( this.pointGrabbed == null && mousepressed && (ctrlPressed||Editor.inPlayMode)
           && !UserIsGrabbing && !UserIsTyping && !UserIsWiring)
        {

            // Try Grab somestuff...
            var px = 0;
            for ( var i = 0 ; i < 5; i++ )
            {
                px += this.ADSRPoints[i].x * (this.bodyBox.w/(this.ADSRPoints.length-1));
                var x = this.bodyBox.x+px;
                var y = this.bodyBox.y+((1-this.ADSRPoints[i].y) * this.bodyBox.h)
                var ptbox = new Box(x-10,y-10, 20, 20);
                if ( IsMouseInsideBox(ptbox,this.displayCanvas)){
                     this.pointGrabbed = i;
                     UserIsGrabbing = true;
                     return;
                }
                
            }
        }
        if ( this.pointGrabbed != null)
        {
            if ( !mousepressed )
            {
                this.pointGrabbed = null;
                UserIsGrabbing = false;
                return;
            }
            // @ Convert mouseX to point x.
            var px = mouseX - this.displayCanvas.box.x - this.bodyBox.x;
            for ( var i = 0 ; i < this.pointGrabbed; i++ )
                px -= this.ADSRPoints[i].x * ((this.bodyBox.w/(this.ADSRPoints.length-1)))
            px /= (this.bodyBox.w/this.ADSRPoints.length)
            if ( px > 1 )
                px = 1;
            if ( px < 0 || this.pointGrabbed == 0)
                px = 0;
            var py = mouseY - this.displayCanvas.box.y - this.bodyBox.y;
            py /= this.bodyBox.h;
            py = 1-py;
            if ( py > 1 )
                py = 1;
            if ( py < 0 || this.pointGrabbed == this.ADSRPoints.length-1 ) // @ Not important?
                py = 0;
            this.ADSRPoints[this.pointGrabbed].x = px;
            this.ADSRPoints[this.pointGrabbed].y = py;
            
        }
        this.DefaultInteract();
    }
}

class Bang extends Block
{
    Draw() 
    {
        // @ Default draw if typing...
        if ( this.renaming)
        {
            this.DefaultDraw();
            return;
        }
        // @ Display Bang graphics 
        var _g = this.displayCanvas.context;
        if (this.drawTrigger > 0 )
        {
            var centerX = this.bodyBox.x + this.bodyBox.w / 2;
            var centerY = this.bodyBox.y + this.bodyBox.h / 2;
            _g.beginPath();
            _g.arc(centerX, centerY, 30, 0, 2* Math.PI, false);
            _g.fillStyle =  'rgb(0,0,255)';
            _g.fill();
            _g.closePath();
            this.drawTrigger--;
        }
        this.bodyBox.w = 20;
        this.bodyBox.h = 20;
        // Draw Body
        this.DrawBody()
        // Draw In and Out
        this.DrawI(this.bodyBox.x + this.bodyBox.w/2,0,1)
        this.DrawO(this.bodyBox.x + this.bodyBox.w/2,0,1)
        
        // Draw custom appearance
        //@ Draw circle
        var centerX = this.bodyBox.x + this.bodyBox.w / 2;
        var centerY = this.bodyBox.y + this.bodyBox.h / 2;
        _g.beginPath();
        _g.arc(centerX, centerY, this.bodyBox.w/2, 0, 2* Math.PI, false);
        _g.fillStyle =  'rgb(255,255,255)';
        if (IsMouseInsideBox(this.bodyBox,this.displayCanvas) && this.displayCanvas.mousepressed && ctrlPressed)
        {
            _g.fillStyle =  'rgb(0,0,255)';
        }
        _g.fill();
        _g.lineWidth = 1;
        _g.strokeStyle = 'rgb(0,0,0)';
        if (IsMouseInsideBox(this.bodyBox,this.displayCanvas) || this.CurrentlyInteract() )
        {
            _g.strokeStyle = 'rgb(0,0,255)';
        }
        _g.stroke();
        _g.closePath();
        
        // @ Draw Wires
        this.DrawWires();
        
    }
    
    Interact()
    {
        // @ Default interaction if typing but prob useless
        if ( this.renaming)
        {
            this.DefaultInteract();
            return;
        }
        if ( this.waspressed == 'undefined')
        {
            this.waspressed = false;
        }
        if ( !this.waspressed && IsMouseInsideBox(this.bodyBox,this.displayCanvas) && mousepressed && (ctrlPressed||Editor.inPlayMode)
           && !UserIsGrabbing && !UserIsTyping && !UserIsWiring)
        {
            this.OIO();
            this.waspressed = true;
            console.log("bang!");
            return ;
        }
        if ( this.waspressed && !mousepressed && (ctrlPressed||Editor.inPlayMode))
        {
            this.waspressed = false;  return;

        }
        this.DefaultInteract();
    }
    O(portnumber,memindex)
    {
       
        // We should i-- to not pass first parameters ...
        var i; 
        for (i = this.outputslots[portnumber].length - 1 ; i >=0 ; i-- )
        {
            var outpbloc = GetBlockByID(this.outputslots[portnumber][i].blocId);
            outpbloc.I
            (
                this.outputslots[portnumber][i].comPort, this.memory[memindex]
            );
        }
        
        // Special bang graphics
        if ( this.Window == Editor.WindowExplorer.Thumbnails[0])
        {
            this.drawTrigger = 2
        }
    }
}