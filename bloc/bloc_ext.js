/*
    All special blocks goes here....
    TODO : 
    // Add comm block, in block, out block
*/

function TryLoadExtensionBlock(originalblock)
{
    // @ index Of
    if ( originalblock.typename.indexOf("in ") == 0)
        return new WarpInBlock(originalblock.typename, Editor.WindowExplorer.Thumbnails[0], originalblock.displayCanvas);
    if ( originalblock.typename.indexOf("out ") == 0)
        return new WarpOutBlock(originalblock.typename, Editor.WindowExplorer.Thumbnails[0], originalblock.displayCanvas);
    // @ equals
    switch ( originalblock.typename)
    {
        case "bang": return new Bang(originalblock.typename, Editor.WindowExplorer.Thumbnails[0], originalblock.displayCanvas);
        case "switch": return new SwitchBlock(originalblock.typename, Editor.WindowExplorer.Thumbnails[0], originalblock.displayCanvas);
        case "number": return new NumBlock(originalblock.typename, Editor.WindowExplorer.Thumbnails[0], originalblock.displayCanvas);
        case "slider": return new SliderBlock(originalblock.typename, Editor.WindowExplorer.Thumbnails[0], originalblock.displayCanvas);
        case "knob": return new KnobBlock(originalblock.typename, Editor.WindowExplorer.Thumbnails[0], originalblock.displayCanvas);
        case "tab": return new TabBlock(originalblock.typename, Editor.WindowExplorer.Thumbnails[0], originalblock.displayCanvas);
        case "graph": return new GraphBlock(originalblock.typename, Editor.WindowExplorer.Thumbnails[0], originalblock.displayCanvas);
        case "msg":  return new MessageBlock(originalblock.typename, Editor.WindowExplorer.Thumbnails[0], originalblock.displayCanvas);
    }
    return null;
}

function DoesBlockHasWireOutToBlock(Block, srcBlock, portNumber)
{
    for ( var i = 0 ; i < Block.outputslots[portNumber].length; i++)
    {
        if ( Block.outputslots[portNumber][i].blocId == srcBlock.id )
            return true;
    }
    return false;
}
class WarpInBlock extends Block
{
    OnCreate()
    {
            console.log("creating warp in ...")
            var typename = this.typename.substr(3,this.typename.length-3);
            // @ Generated inputscript
            var genscript = new Array();
            genscript.push("# AutoGenerated Code for Warping");
            genscript.push("# @ Logic for [IN "+typename+"] block");
            genscript.push("--decl");
            genscript.push("inp(1)"); 
            genscript.push("outp(1)");
            genscript.push("memset(1)");
            genscript.push("--code");
            genscript.push("out0(0)");
            this.NativeScript = genscript;
            // Force compiling
        
            this.SetInputCount(1);
            this.SetOutputCount(1);
        
            ide.TryLoadBlock(this);
            this.AutoWiringSet = false;
    }
    Interact()
    {
        if ( !this.AutoWiringSet )
        {
            this.AutoWiringSet = true;
            // Search for any in blocs...
            var typename = this.typename.substr(3,this.typename.length-3);
            var outblocs = GetAllBlocksByTypeName("out "+typename);
            for (var i=0;i<outblocs.length;i++)
            {
                if ( !DoesBlockHasWireOutToBlock(outblocs[i], this, 0))
                {
                    outblocs[i].AddWireOut(0, this.id, 0);
                }
               
            }
            
        }
        this.DefaultInteract();
    }
    Draw()
    {
          // Compute Width and Port distance
        var w = this.typename.length * VisualParameters.BlockFontWidth; 
        if ( w < 25 )
        {
            w = 40 ;
        }
        var maxSlot = this.inputslots.length;
        if (  this.outputslots.length > maxSlot){
            maxSlot = this.outputslots.length;
        }
        
        var segwidth = w /maxSlot ;
        if ( segwidth < 10 * 1.5){
            // recompute w 
            segwidth = 10 * 1.5;
            w = maxSlot *segwidth;
        }
        
        this.bodyBox.w = w;
        this.bodyBox.h = 25;
        
        var iostartpos  = this.bodyBox.x + this.bodyBox.w/segwidth ; 
         
        // @ Draw Boxes
        this.DrawBody()
        
        // @ Draw IOs
        this.DrawO(iostartpos,segwidth,this.outputslots.length)
        
        // @ Print text
        var _g = this.displayCanvas.context;
        _g.fillStyle = VisualParameters.BlockStrokeColor;
        if (this.renaming)
        {
            _g.fillStyle = VisualParameters.BlockFillColor;
        }
        _g.font = VisualParameters.BlockFont;
        _g.fillText(this.typename,this.bodyBox.x,this.bodyBox.y+16 );
        
        // @ Draw Wires
        this.DrawWires();
    }
}
class WarpOutBlock extends Block
{
    OnCreate()
    {
       
           var typename = this.typename.substr(4,this.typename.length-4);
            // @ Generated outscript
            var outscript = new Array();
            outscript.push("# AutoGenerated Code for Warping");
            outscript.push("# @ Logic for [OUT "+typename+"] block");
            outscript.push("--decl");
            outscript.push("inp(1)"); // Do not draw for Input
            outscript.push("outp(1)");
            outscript.push("memset(1)");
            outscript.push("--code");
            outscript.push("out0(0)");
            this.NativeScript = outscript;
        
            this.SetInputCount(1);
            this.SetOutputCount(1);
            
            
        
            var inblocs = GetAllBlocksByTypeName("in "+typename);
            // create a new [in block]
            if (inblocs.length == 0 )
            {
                Editor.AddNewWindow(Editor.GetEmptyWindow());
                var inbloc = CreateSpecificBlock("in "+typename, this.displayCanvas.box.w/2,this.displayCanvas.box.h/2 );
                    
            } 
            // At least one bloc has been created. But its id will change after load... we need to define another strategy. For example in interact loop (how boring)
            this.AutoWiringSet = false;
    }
    Interact()
    {
        if ( !this.AutoWiringSet )
        {
            this.AutoWiringSet = true;
            // Search for any in blocs...
            var typename = this.typename.substr(4,this.typename.length-4);
            var inblocs = GetAllBlocksByTypeName("in "+typename);
            for (var i=0;i<inblocs.length;i++)
            {
                if ( !DoesBlockHasWireOutToBlock(this, inblocs[i], 0))
                {
                    this.AddWireOut(0, inblocs[i].id, 0);
                }
               
            }
            
        }
        // On click extends to inblock 0
        if (  IsMouseInsideBox(this.bodyBox,this.displayCanvas) 
            && mousepressed && (ctrlPressed||Editor.inPlayMode)
            && !UserIsGrabbing && !UserIsTyping && !UserIsWiring)
        {
            var typename = this.typename.substr(4,this.typename.length-4);
            var b = GetBlockByTypeName("in " +typename);
            if ( b != null)
                Editor.AddNewWindow(b.Window);
            return ;
        }
        this.DefaultInteract();
    }
    Draw()
    {
          // Compute Width and Port distance
        var w = this.typename.length * VisualParameters.BlockFontWidth; 
        if ( w < 25 )
        {
            w = 40 ;
        }
        var maxSlot = this.inputslots.length;
        if (  this.outputslots.length > maxSlot){
            maxSlot = this.outputslots.length;
        }
        
        var segwidth = w /maxSlot ;
        if ( segwidth < 10 * 1.5){
            // recompute w 
            segwidth = 10 * 1.5;
            w = maxSlot *segwidth;
        }
        
        this.bodyBox.w = w;
        this.bodyBox.h = 25;
        
        var iostartpos  = this.bodyBox.x + this.bodyBox.w/segwidth ; 
         
        // @ Draw Boxes
        this.DrawBody()
        
        // @ Draw IOs
        this.DrawI(iostartpos,segwidth,this.inputslots.length)
        //this.DrawIOs(iostartpos,segwidth,this.inputslots.length, this.outputslots.length )
        
        // @ Print text
        var _g = this.displayCanvas.context;
        _g.fillStyle = VisualParameters.BlockStrokeColor;
        if (this.renaming)
        {
            _g.fillStyle = VisualParameters.BlockFillColor;
        }
        _g.font = VisualParameters.BlockFont;
        _g.fillText(this.typename,this.bodyBox.x,this.bodyBox.y+16 );
        
    }
}
class MessageBlock extends Block
{
    Draw() 
    {
     
        var w = this.memory[1].toString().length * 12; // we could mesure text... here 
        if ( w < 25 )
        {
             w = 40 ;
        }
        this.bodyBox.w = w;
        this.bodyBox.h = 25;
        // Draw Body
        this.DrawBody()
        // Draw In and Out
        this.DrawI(this.bodyBox.x + this.bodyBox.w/2,0,1)
        this.DrawO(this.bodyBox.x + this.bodyBox.w/2,0,1)
         var _g = this.displayCanvas.context;
        // Draw custom appearance
         _g.fillStyle = 'rgb(0,0,0)';
        _g.font = "16px Autopia";
        _g.fillText(this.memory[1].toString(),this.bodyBox.x + 5,this.bodyBox.y+16 );
        
         // @ Draw Wires
        this.DrawWires();
    }
    DrawBody()
    {
        var _g = this.displayCanvas.context;
        // @ Draw Box
        // Plain color
        _g.fillStyle = VisualParameters.BlockFillColor;
        if (this.renaming)
        {
            _g.fillStyle = VisualParameters.BlockHighLightColor;
        }
        _g.fillRect(this.bodyBox.x,this.bodyBox.y,this.bodyBox.w,this.bodyBox.h);
        
        // Outline
        _g.lineWidth = VisualParameters.BlockBorderWidth;
        _g.strokeStyle = VisualParameters.BlockStrokeColor;
        if (this.renaming )
        {
            _g.strokeStyle = VisualParameters.BlockFillColor;
        }
        if (IsMouseInsideBox(this.bodyBox,this.displayCanvas) || this.CurrentlyInteract() )
        {
            _g.strokeStyle = VisualParameters.BlockHighLightColor;
            Editor.Info = GetDocOfNativeScriptFromToken(this.NativeScript, "#df");
        }
        // if this is in library 
        // stroke special rect 
          var peaksize = 10;
         this.displayCanvas.DrawLine(this.bodyBox.x + this.bodyBox.w , this.bodyBox.y,this.bodyBox.x, this.bodyBox.y);
         this.displayCanvas.DrawLine(this.bodyBox.x, this.bodyBox.y , this.bodyBox.x, this.bodyBox.y+this.bodyBox.h);
         this.displayCanvas.DrawLine(this.bodyBox.x, this.bodyBox.y+this.bodyBox.h , this.bodyBox.x+this.bodyBox.w, this.bodyBox.y+this.bodyBox.h);
        
         this.displayCanvas.DrawLine(this.bodyBox.x + this.bodyBox.w , this.bodyBox.y , this.bodyBox.x+this.bodyBox.w-peaksize, this.bodyBox.y+this.bodyBox.h/2);
         this.displayCanvas.DrawLine(this.bodyBox.x+this.bodyBox.w-peaksize, this.bodyBox.y+this.bodyBox.h/2,this.bodyBox.x + this.bodyBox.w, this.bodyBox.y+this.bodyBox.h);
        
    }
    ProccessRenaming(e)
    {
        
        if ( e.keyCode == 46 ) //@ key suppr was pressed  
        {
            this.Destroy();
            UserIsTyping = false;
            return; 
        }
        
       if ( e.keyCode == 13 ) // @ key enter was pressed 
        {
           
            this.renaming = false;
            UserIsTyping = false;
            return;
        }
        if (  e.keyCode == 8 )
            this.memory[1] = this.memory[1].substr(0,this.memory[1].length-1);
        else
        {
            if ( !KeyIsIllegal(e.key))
            {
                this.memory[1] += e.key;
            }
             
        }
        return;
        
    }
    TryInteract()
    {
        var i; 
        for (i = 0 ; i < this.inputsboxes.length; i++)
        {
            if (IsMouseInsideBox(this.inputsboxes[i], this.displayCanvas))
            {
                 if ( Editor.hasdoubleclicked )
                 {
                    this.grabbed = false; 
                    UserIsGrabbing = false;
                    this.ClearInputPort(i);
                    return;
                 }
                 this.wiringData = new WiringInfo(this.id, i, true);
                 UserIsWiring = true;
                 return;
            }
        }
        for (i = 0 ; i < this.outputsboxes.length; i++)
        {
            if (IsMouseInsideBox(this.outputsboxes[i],this.displayCanvas))
            {
                if ( Editor.hasdoubleclicked )
                {
                    this.grabbed = false;  
                    UserIsGrabbing = false;
                    this.ClearOutputPort(i);
                    return;
                }
                this.wiringData = new WiringInfo(this.id, i, false);
                UserIsWiring = true;
                return;
            }
        }      
    
        if (!IsMouseInsideBox(this.bodyBox,this.displayCanvas))
            return;
        
        // @ Update Code Editor 
        ide.TryLoadBlock(this)
        
        if ( Editor.hasdoubleclicked == true && !UserIsTyping)
        {
            // @ Destroy grabbed data... it can leave on the block
            this.grabbed = false;
            UserIsGrabbing = false;
            this.renaming = true;
            UserIsTyping = true;
            return;
        }
        
        // @ Do Grabbing
        this.GrabOrigin = new Vector2(mouseX-this.bodyBox.x, mouseY - this.bodyBox.y);
        this.grabbed = true;
        UserIsGrabbing = true;
    }
    Interact()
    {
        // @ Default interaction if typing but prob useless
        if ( this.renaming)
        {
            this.DefaultInteract();
            return;
        }
        if ( this.waspressed == 'undefined')
        {
            this.waspressed = false;
        }
        if ( !this.waspressed && IsMouseInsideBox(this.bodyBox,this.displayCanvas) 
            && mousepressed && (ctrlPressed||Editor.inPlayMode)
            && !UserIsGrabbing && !UserIsTyping && !UserIsWiring)
        {
            this.OIO();
            this.waspressed = true;
            return ;
        }
        if ( this.waspressed && !mousepressed && (ctrlPressed||Editor.inPlayMode) )
        {
            this.waspressed = false;  return;

        }
        this.DefaultInteract();
    }
} 
class SwitchBlock extends Block
{
    Draw() 
    {
        // @ Default draw if typing...
        if ( this.renaming)
        {
            this.DefaultDraw();
            return;
        }
        // @ Display Bang graphics 
        var _g = this.displayCanvas.context;
        
        this.bodyBox.w = 20;
        this.bodyBox.h = 20;
        // Draw Body
        this.DrawBody()
        // Draw In and Out
        this.DrawI(this.bodyBox.x + this.bodyBox.w/2,0,1)
        this.DrawO(this.bodyBox.x + this.bodyBox.w/2,0,1)
        
        // Draw custom appearance
        //@ Draw Cross 
        if ( this.memory[1] > 0)
        {
            _g.strokeStyle = "rgba(0,0,0)"; 
            _g.lineWidth = 3;

            // First line 
            _g.beginPath();
            _g.moveTo(this.bodyBox.x, this.bodyBox.y);
            _g.lineTo(this.bodyBox.x+this.bodyBox.w, this.bodyBox.y+this.bodyBox.h);
            _g.closePath();
            _g.stroke();
            // sec line 
            _g.beginPath();
            _g.moveTo(this.bodyBox.x, this.bodyBox.y+this.bodyBox.h);
            _g.lineTo(this.bodyBox.x+this.bodyBox.w, this.bodyBox.y);
            _g.closePath();
            _g.stroke();
        }
        
        // @ Draw Wires
        this.DrawWires();
        
    }
    Interact()
    {
        if ( this.renaming)
        {
            this.DefaultInteract();
            return;
        }
        if ( this.waspressed == 'undefined')
        {
            this.waspressed = false;
        }
        if ( !this.waspressed && IsMouseInsideBox(this.bodyBox,this.displayCanvas) && mousepressed && (ctrlPressed||Editor.inPlayMode)
           && !UserIsGrabbing && !UserIsTyping && !UserIsWiring)
        {
            this.waspressed = true;
            if ( this.memory[1] > 0 )
                this.memory[1] = 0;
            else
                this.memory[1] = 1;

            return;
        }
        if ( this.waspressed && !mousepressed && (ctrlPressed||Editor.inPlayMode) )
        {
            this.waspressed = false; return;

        } 
        this.DefaultInteract();
    }
}
class NumBlock extends Block
{
    Draw() 
    {
        if ( this.renaming)
        {
            this.DefaultDraw();
            return;
        }
        var w = this.memory[0].toString().length * 12;
        if ( w < 25 )
        {
             w = 40 ;
        }
        this.bodyBox.w = w;
        this.bodyBox.h = 25;
        // Draw Body
        this.DrawBody()
        // Draw In and Out
        this.DrawI(this.bodyBox.x + this.bodyBox.w/2,0,1)
        this.DrawO(this.bodyBox.x + this.bodyBox.w/2,0,1)
         var _g = this.displayCanvas.context;
        // Draw custom appearance
         _g.fillStyle = 'rgb(0,0,0)';
        _g.font = "16px Autopia";
        _g.fillText(this.memory[0].toString(),this.bodyBox.x + 5,this.bodyBox.y+16 );
        
         // @ Draw Wires
        this.DrawWires();
    }
    Interact()
    {
        // @ Default interaction if typing but prob useless
        if ( this.renaming)
        {
            this.DefaultInteract();
            return;
        }
        if ( IsMouseInsideBox(this.bodyBox,this.displayCanvas) && mousepressed && (ctrlPressed||Editor.inPlayMode)
           && !UserIsGrabbing && !UserIsTyping && !UserIsWiring)
        {
            this.waspressed = true;
        }
        if ( this.waspressed == true && mousepressed && (ctrlPressed||Editor.inPlayMode))
        {
             // Get MouseY distance from bodyboxY
            var val = (mouseY - this.displayCanvas.box.y) - this.bodyBox.y; 
            val = Math.floor(val/2);
            this.memory[0] = this.tempmemvalue - val;
            // Get Mouse relative to 
            this.OIO();
            return;
        }
        // @ Save a temp memory 
        this.waspressed = false;
        this.tempmemvalue = this.memory[0];
        this.DefaultInteract();
    }
} 
class SliderBlock extends Block
{
    Draw() 
    {

        // @ Default draw if typing...
        if ( this.renaming)
        {
            this.DefaultDraw();
            return;
        }
        // @ Display Bang graphics 
        var _g = this.displayCanvas.context;
        this.bodyBox.w = 20;
        this.bodyBox.h = 100;
        // Draw Body
        this.DrawBody()
        // Draw In and Out
        this.DrawI(this.bodyBox.x + this.bodyBox.w/2,0,1)
        this.DrawO(this.bodyBox.x + this.bodyBox.w/2,0,1)
        
        // Draw custom appearance
        var min = 0; 
        var max = 200;
        var sliderpos = this.memory[0] / max;
        _g.fillStyle = 'rgb(0,0,255)';
        _g.fillRect(this.bodyBox.x,this.bodyBox.y+sliderpos* this.bodyBox.h,this.bodyBox.w,this.bodyBox.h/16);
        
        // @ Draw Wires
        this.DrawWires();
        
    }
    Interact()
    {
        // @ Default interaction if typing but prob useless
        if ( this.renaming)
        {
            this.DefaultInteract();
            return;
        }
        if ( IsMouseInsideBox(this.bodyBox,this.displayCanvas) && mousepressed && (ctrlPressed||Editor.inPlayMode)
           && !UserIsGrabbing && !UserIsTyping && !UserIsWiring)
        {
            // Redraw slider at pos. Then recompute Mem(0)
            var _g = this.displayCanvas.context;
            var w = 20; // can be in param
            var h = 100; // can be in param
            var min = 0; // can be in param
            var max = 200;// can be in param
            var sliderpos = this.memory[0] / max;
            _g.fillStyle = 'rgb(0,0,255)';
            _g.fillRect(this.bodyBox.x,mouseY-this.displayCanvas.box.y,w,h/16);
            // @ Set Mem value
            this.memory[0] = (mouseY-this.displayCanvas.box.y - this.bodyBox.y) * max /  h;
            // bang ! 
            this.OIO();
            return;
        }
        this.DefaultInteract();
    }
}  
class KnobBlock extends Block
{
    Draw() 
    {
        // @ Default draw if typing...
        if ( this.renaming)
        {
            this.DefaultDraw();
            return;
        }
        // @ Display Bang graphics 
        var _g = this.displayCanvas.context;
        this.bodyBox.w = 60;
        this.bodyBox.h = 60;
        
        // Draw Body
        var centerX = this.bodyBox.x + this.bodyBox.w / 2;
        var centerY = this.bodyBox.y + this.bodyBox.h / 2;
        _g.beginPath();
        _g.arc(centerX, centerY, this.bodyBox.w/2, 0, 2* Math.PI, false);
        _g.fillStyle =  'rgb(255,255,255)';
        _g.fill();
        _g.lineWidth = 3;
        _g.strokeStyle = 'rgb(0,0,0)';
        if (IsMouseInsideBox(this.bodyBox,this.displayCanvas) || this.CurrentlyInteract() )
        {
            _g.strokeStyle = 'rgb(0,0,255)';
        }
        _g.stroke();
        _g.closePath();
        
        // Draw In and Out
        this.DrawI(this.bodyBox.x + this.bodyBox.w/2,0,1)
        this.DrawO(this.bodyBox.x + this.bodyBox.w/2,0,1)
        
        // Draw knob bar
         var min = 0; 
         var max = 200;

         // @ get angle
         var angle = (this.memory[0] / max) * 360; 
         angle += 90; 
         _g.strokeStyle = "rgba(0,0,0)"; 
         _g.lineWidth = 5;
         _g.beginPath();
         _g.moveTo( centerX ,centerY);
          var aX = centerX + (this.bodyBox.w/2 * Math.cos(degrees_to_radians(angle)));  
          var aY = centerY + (this.bodyBox.w/2 * Math.sin(degrees_to_radians(angle)));
         _g.lineTo(aX,aY);
         _g.closePath();
         _g.stroke();
    
        
        // @ Draw Wires
        this.DrawWires();
        
    }
    Interact()
    {
        // @ Default interaction if typing but prob useless
        if ( this.renaming)
        {
            this.DefaultInteract();
            return;
        }
         if ( IsMouseInsideBox(this.bodyBox,this.displayCanvas) && mousepressed && (ctrlPressed||Editor.inPlayMode)
            && !UserIsGrabbing && !UserIsTyping && !UserIsWiring)
        {
            // Redraw slider at pos. Then recompute Mem(0)
            var _g = this.displayCanvas.context;
            var w = 60;
            var min = 0; 
            var max = 200;
            var centerX = this.bodyBox.x + this.bodyBox.w / 2;
            var centerY = this.bodyBox.y + this.bodyBox.h / 2;
            var angle = getAngle(mouseX-this.displayCanvas.box.x, mouseY-this.displayCanvas.box.y, centerX,centerY );
            angle = 360 - (angle);

            var adjustedAngle = angle- 90;
            if ( adjustedAngle <= 0 )
                adjustedAngle = 270 + (90+adjustedAngle);

            // @ set memory 0 to 
            this.memory[0] = (adjustedAngle / 360) * max;


           _g.strokeStyle = "rgba(0,0,0)"; 
           _g.lineWidth = 5;
           _g.beginPath();
           _g.moveTo( centerX ,centerY);
           var aX = centerX + (w/2 * Math.cos(degrees_to_radians(angle)));  
           var aY = centerY + (w/2 * Math.sin(degrees_to_radians(angle)));
           _g.lineTo(aX,aY);
           _g.closePath();
           _g.stroke();

            // Call IOI
            this.OIO();

            return;
        }
        this.DefaultInteract();
    }
} 
class TabBlock extends Block
{
    Draw()
    {
        // @ Default draw if typing...
        if ( this.renaming)
        {
            this.DefaultDraw();
            return;
        }
        var _g = this.displayCanvas.context;
        this.bodyBox.w = 100;
        this.bodyBox.h = 100;
        // Draw Body
        this.DrawBody()
        
        // Draw pixel values
        var pixsize = this.bodyBox.w / this.memory[3].length;
        // set pixel color
        _g.fillStyle = 'rgb(0,0,255)';
        var i;
        for (i = 0 ; i < this.memory[3].length; i++ )
        {
            // draw pix as color
            var p = this.memory[3][i];
            _g.fillRect(this.bodyBox.x+(i*pixsize),this.bodyBox.y+p,pixsize,pixsize);
        }
        // Draw IO
        var segwidth = this.bodyBox.w / 3 ; // width divide by maxslot which is 3  
        var iostartpos  = this.bodyBox.x +this.bodyBox.w/segwidth ;
        this.DrawI(iostartpos,segwidth,this.inputslots.length);
        this.DrawO(iostartpos,segwidth,this.outputslots.length);
        
         // @ Draw Wires
        this.DrawWires();
    }
    Interact()
    {
        // @ Default interaction if typing but prob useless
        if ( this.renaming)
        {
            this.DefaultInteract();
            return;
        }
        if ( IsMouseInsideBox(this.bodyBox,this.displayCanvas) && mousepressed && (ctrlPressed||Editor.inPlayMode)
           && !UserIsGrabbing && !UserIsTyping && !UserIsWiring)
        {
           var val = mouseY - this.displayCanvas.box.y - this.bodyBox.y;
           var index = Math.round((mouseX - this.displayCanvas.box.x - this.bodyBox.x) / 100 * 50);
           this.memory[3][index] = val; return;
        }
        this.DefaultInteract();
    }
}
class GraphBlock extends Block
{
    Draw()
    {
        if ( this.renaming)
        {
            this.DefaultDraw();
            return;
        }
        // @ Display Graph graphics 
        var _g = this.displayCanvas.context;
        this.bodyBox.w = 100;
        this.bodyBox.h = 100;
        // Draw Body
        this.DrawBody()
        // Draw pix values 
        var pixsize = this.bodyBox.w /this.memory[5].length;
        // set pixel color
        _g.fillStyle = 'rgb(0,0,255)';
        var i;
        for (i = 0 ; i <this.memory[5].length; i++ )
        {
            // draw pix as color
            var n;
            for (n = 0; n < this.memory[5][i].length; n++)
            {
                if ( this.memory[5][i][n] > 0 )
                {
                    _g.fillRect(this.bodyBox.x+(i*pixsize),this.bodyBox.y+(n*pixsize),pixsize,pixsize);
                }
            }

        }
        var segwidth = this.bodyBox.w / 5 ;   
        var iostartpos  = this.bodyBox.x +this.bodyBox.w/segwidth ;
        this.DrawI(iostartpos,segwidth,this.inputslots.length);
        this.DrawO(iostartpos,segwidth,this.outputslots.length);
          // @ Draw Wires
        this.DrawWires();
    }
    Interact()
    {
        // @ Default interaction if typing but prob useless
        if ( this.renaming)
        {
            this.DefaultInteract();
            return;
        }
        if ( IsMouseInsideBox(this.bodyBox,this.displayCanvas) && mousepressed && (ctrlPressed||Editor.inPlayMode)
           && !UserIsGrabbing && !UserIsTyping && !UserIsWiring)
        {
            var x = Math.round((mouseX - this.displayCanvas.box.x - this.bodyBox.x) / 100 * 50);
            var y = Math.round((mouseY - this.displayCanvas.box.y - this.bodyBox.y) / 100 * 50);
            this.memory[5][x][y] = 1;
            return;
        }
        this.DefaultInteract();
    }
} 

class Bang extends Block
{
    Draw() 
    {
        // @ Default draw if typing...
        if ( this.renaming)
        {
            this.DefaultDraw();
            return;
        }
        // @ Display Bang graphics 
        var _g = this.displayCanvas.context;
        this.bodyBox.w = 20;
        this.bodyBox.h = 20;
        // Draw Body
        this.DrawBody()
        // Draw In and Out
        this.DrawI(this.bodyBox.x + this.bodyBox.w/2,0,1)
        this.DrawO(this.bodyBox.x + this.bodyBox.w/2,0,1)
        
        // Draw custom appearance
        //@ Draw circle
        var centerX = this.bodyBox.x + this.bodyBox.w / 2;
        var centerY = this.bodyBox.y + this.bodyBox.h / 2;
        _g.beginPath();
        _g.arc(centerX, centerY, this.bodyBox.w/2, 0, 2* Math.PI, false);
        _g.fillStyle =  'rgb(255,255,255)';
        if (IsMouseInsideBox(this.bodyBox,this.displayCanvas) && this.displayCanvas.mousepressed && ctrlPressed)
        {
            _g.fillStyle =  'rgb(0,0,255)';
        }
        _g.fill();
        _g.lineWidth = 1;
        _g.strokeStyle = 'rgb(0,0,0)';
        if (IsMouseInsideBox(this.bodyBox,this.displayCanvas) || this.CurrentlyInteract() )
        {
            _g.strokeStyle = 'rgb(0,0,255)';
        }
        _g.stroke();
        _g.closePath();
        
        // @ Draw Wires
        this.DrawWires();
        
    }
    
    Interact()
    {
        // @ Default interaction if typing but prob useless
        if ( this.renaming)
        {
            this.DefaultInteract();
            return;
        }
        if ( this.waspressed == 'undefined')
        {
            this.waspressed = false;
        }
        if ( !this.waspressed && IsMouseInsideBox(this.bodyBox,this.displayCanvas) && mousepressed && (ctrlPressed||Editor.inPlayMode)
           && !UserIsGrabbing && !UserIsTyping && !UserIsWiring)
        {
            this.OIO();
            this.waspressed = true;
            console.log("bang!");
            return ;
        }
        if ( this.waspressed && !mousepressed && (ctrlPressed||Editor.inPlayMode))
        {
            this.waspressed = false;  return;

        }
        this.DefaultInteract();
    }
    O(portnumber,memindex)
    {
       
        // We should i-- to not pass first parameters ...
        var i; 
        for (i = this.outputslots[portnumber].length - 1 ; i >=0 ; i-- )
        {
            var outpbloc = GetBlockByID(this.outputslots[portnumber][i].blocId);
            outpbloc.I
            (
                this.outputslots[portnumber][i].comPort, this.memory[memindex]
            );
        }
        
        // Special bang graphics
        if ( this.Window == Editor.WindowExplorer.Thumbnails[0])
        {
            //@ Draw circle
            var _g = this.displayCanvas.context;
            var centerX = this.bodyBox.x + this.bodyBox.w / 2;
            var centerY = this.bodyBox.y + this.bodyBox.h / 2;
            _g.beginPath();
            _g.arc(centerX, centerY, 30, 0, 2* Math.PI, false);
            _g.fillStyle =  'rgb(0,0,255)';
            _g.fill();
            _g.closePath();
        }
    }
}